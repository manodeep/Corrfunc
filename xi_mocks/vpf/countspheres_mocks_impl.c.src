/* File: countspheres_mocks_impl.c.src */
/*
  This file is a part of the Corrfunc package
  Copyright (C) 2015-- Manodeep Sinha (manodeep@gmail.com)
  License: MIT LICENSE. See LICENSE file under the top-level
  directory at https://github.com/manodeep/Corrfunc/
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <gsl/gsl_interp.h>

#include "defs.h"
#include "cellarray_DOUBLE.h" //definition of struct cellarray* (NOTE theory versions of cellarray header)
#include "gridlink_impl_DOUBLE.h"//function proto-type for gridlink (NOTE we are getting the theory gridlink)
#include "cpu_features.h"
#include "set_cosmo_dist.h"//cosmological distance calculations
#include "cosmology_params.h"//init_cosmology
#include "utils.h" //all of the utilities
#include "progressbar.h" //for the progressbar

#include "countspheres_mocks_impl_DOUBLE.h" //function proto-type

#include "vpf_mocks_kernels_DOUBLE.c"

int interrupt_status_vpf_mocks_DOUBLE=EXIT_SUCCESS;

void interrupt_handler_vpf_mocks_DOUBLE(int signo)
{
    fprintf(stderr,"Received signal = `%s' (signo = %d). Aborting \n",strsignal(signo), signo);
    interrupt_status_vpf_mocks_DOUBLE = EXIT_FAILURE;
}    


int count_neighbors_DOUBLE(const DOUBLE xcen,const DOUBLE ycen,const DOUBLE zcen,const DOUBLE smin,const DOUBLE inv_rcube,const DOUBLE rmax,
                           const int ngrid,const cellarray_DOUBLE *lattice, const int nthreshold, const int bin_refine_factor);

vpf_mocks_func_ptr_DOUBLE vpf_mocks_driver_DOUBLE(const struct config_options *options) 
{
  static int initialized = 0;
  static vpf_mocks_func_ptr_DOUBLE function = NULL;

  if(initialized == 1) return function;

  //the fastest available code will always be at index 0.
  if(initialized == 0) {
    //Seriously this is the declaration for the function pointers...here be dragons.
    vpf_mocks_func_ptr_DOUBLE allfunctions[] = {
#ifdef __AVX__
      vpf_mocks_avx_intrinsics_DOUBLE,
#endif			 
#ifdef __SSE4_2__
      vpf_mocks_sse_intrinsics_DOUBLE,
#endif
      vpf_mocks_fallback_DOUBLE
    };
    const int num_functions = sizeof(allfunctions)/sizeof(void *);
    const int fallback_offset = num_functions - 1;
    const int highest_isa = instrset_detect();
    
    int curr_offset = 0;
    
    /* Now check if AVX is supported by the CPU */
    int avx_offset = fallback_offset;
#ifdef __AVX__
    avx_offset = highest_isa >= 7 ? curr_offset:fallback_offset;
    curr_offset++;
#endif        
    
    /* Is the SSE function supported at runtime and enabled at compile-time?*/
    int sse_offset = fallback_offset;
#ifdef __SSE4_2__
    sse_offset = highest_isa >= 6 ? curr_offset:fallback_offset;
    curr_offset++;
#endif
    if( curr_offset != fallback_offset) {
      fprintf(stderr,"ERROR: Bug in code (current offset = %d *should equal* fallback function offset = %d)\n",
              curr_offset, fallback_offset);
      return NULL;
    } 
    
    int function_dispatch=0;
    /* Check that cpu supports feature */
    if(options->instruction_set != 0) {
      switch(options->instruction_set) {
      case(AVX):
        function_dispatch=avx_offset;break;
      case(SSE):function_dispatch=sse_offset;break;
      default:function_dispatch=fallback_offset;break;
      }
    }

    if(function_dispatch >= num_functions) {
      fprintf(stderr,"In %s> ERROR: Could not resolve the correct function.\n Function index = %d must lie between [0, %d)\n",
              __FUNCTION__, function_dispatch, num_functions);
      return NULL;
    }
    function = allfunctions[function_dispatch];
    initialized = 1;
  }

  return function;
}


int count_neighbors_DOUBLE(const DOUBLE xcen,const DOUBLE ycen,const DOUBLE zcen,const DOUBLE smin,const DOUBLE inv_rcube,const DOUBLE rmax,
                           const int ngrid,const cellarray_DOUBLE *lattice, const int nthreshold, const int bin_refine_factor)
{
    int numngb=0;
    const DOUBLE rmax_sqr = (DOUBLE) (rmax*rmax);
    int ix = (int)(ngrid*(xcen-smin)*inv_rcube);
    int iy = (int)(ngrid*(ycen-smin)*inv_rcube);
    int iz = (int)(ngrid*(zcen-smin)*inv_rcube);
    if(ix > ngrid-1) ix--;
    if(iy > ngrid-1) iy--;
    if(iz > ngrid-1) iz--;

    if( ix  < 0 || ix >= ngrid || iy < 0 || iy >= ngrid || iz < 0 || iz >= ngrid) {
        fprintf(stderr,"Error in %s> Positions are outside grid. (X,Y,Z) = (%lf,%lf,%lf) should have been within the range [0.0, %lf]\n",
                __FUNCTION__,xcen, ycen, zcen, 1.0/inv_rcube);
        return -1;
    }

    const int min_ix = ix - bin_refine_factor < 0 ?             0:ix - bin_refine_factor;
    const int max_ix = ix + bin_refine_factor > ngrid-1 ? ngrid-1:ix + bin_refine_factor;
    for(int iix=min_ix;iix<=max_ix;iix++) {
        const DOUBLE newxpos = xcen;
        const int min_iy = iy - bin_refine_factor < 0 ?             0:iy - bin_refine_factor;
        const int max_iy = iy + bin_refine_factor > ngrid-1 ? ngrid-1:iy + bin_refine_factor;

        for(int iiy=min_iy;iiy<=max_iy;iiy++) {
            const DOUBLE newypos = ycen;
            const int min_iz = iz - bin_refine_factor < 0 ?             0:iz - bin_refine_factor;
            const int max_iz = iz + bin_refine_factor > ngrid-1 ? ngrid-1:iz + bin_refine_factor;

            for(int iiz=min_iz;iiz<=max_iz;iiz++) {
                DOUBLE newzpos = zcen;
                const int64_t index=iix*ngrid*ngrid + iiy*ngrid + iiz;
                const cellarray_DOUBLE *cellstruct = &(lattice[index]);
                DOUBLE *x2 = cellstruct->x;
                DOUBLE *y2 = cellstruct->y;
                DOUBLE *z2 = cellstruct->z;

                for(int i=0;i<cellstruct->nelements;i+=NVEC) {
                    int block_size = cellstruct->nelements - i ;
                    if(block_size > NVEC) block_size = NVEC;
                    for(int ii=0;ii<block_size;ii++) {
                        const DOUBLE dx=x2[ii]-newxpos;
                        const DOUBLE dy=y2[ii]-newypos;
                        const DOUBLE dz=z2[ii]-newzpos;
                        const DOUBLE r2 = dx*dx + dy*dy + dz*dz;
                        if (r2 < rmax_sqr) numngb++;
                    }
                    if(numngb > nthreshold) return numngb;

                    x2 += NVEC;
                    y2 += NVEC;
                    z2 += NVEC;

                }
            }
        }
    }
    return numngb;
}


int countspheres_mocks_DOUBLE(const int64_t Ngal, DOUBLE *xgal, DOUBLE *ygal, DOUBLE *zgal,
                              const int64_t Nran, DOUBLE *xran, DOUBLE *yran, DOUBLE *zran,
                              const int threshold_neighbors,
                              const DOUBLE rmax, const int nbin, const int nc,
                              const int num_pN,
                              const char *centers_file,
                              const int cosmology,
                              results_countspheres_mocks *results,
                              const struct config_options *input_options)
    
{
    int ngrid;
    int itry,isucceed;

    //Input validation
    XRETURN(rmax > 0.0, EXIT_FAILURE, "rmax=%lf has to be positive", rmax);
    XRETURN(nbin >=1, EXIT_FAILURE,"Number of bins=%d has to be at least 1", nbin);
    XRETURN(nc >=1,EXIT_FAILURE,"Number of spheres=%d has to be at least 1", nc);
    XRETURN(num_pN >= 1, EXIT_FAILURE,"Number of pN's=%d requested must be at least 1", num_pN);

    /* Start cosmology */
    {
        // Declared in separate scope so I can call the variable status;
        int status = init_cosmology(cosmology);
        if(status != EXIT_SUCCESS) {
            return status;
        }
    }

    struct config_options options = *input_options;
    options.periodic=0;

    /* setup interrupt handler -> mostly useful during the python execution. 
       Let's Ctrl-C abort the extension  */
    int interrupt_signals[] = {SIGTERM, SIGINT, SIGHUP};
    for(size_t i=0;i<sizeof(interrupt_signals)/sizeof(interrupt_signals[0]);i++) {
        int signo = interrupt_signals[i];
        if (signal(signo, interrupt_handler_vpf_mocks_DOUBLE) == SIG_ERR) {
            fprintf(stderr,"Can not handle signal = %d\n", signo);
        }
    }
    
    int need_randoms=0;
    int64_t num_centers_in_file=0;
    FILE *fpcen = fopen(centers_file,"r");
    if(fpcen != NULL) {
        double rr = 0.0;
        int num_read = fscanf(fpcen,"%*f %*f %*f %lf",&rr);
        XRETURN(num_read == 1,EXIT_FAILURE, "Could not read max. sphere radius from the centers file");
        num_centers_in_file = getnumlines(centers_file,'#');
        if( rr >= rmax && num_centers_in_file >= nc) {
            need_randoms = 0;
            rewind(fpcen);
        } else {
            fclose(fpcen);
            num_centers_in_file = 0;
            need_randoms = 1;
        }
    } else {
        num_centers_in_file = 0;
        need_randoms = 1;
    }
    if(need_randoms==1) {
        fpcen = my_fopen(centers_file,"w");
    }
    if(options.verbose) {
        fprintf(stderr,"%s> found %"PRId64" centers (need %d centers) - need randoms = %d\n",__FUNCTION__,num_centers_in_file,nc,need_randoms);
    }


    //set up the interpolation for comoving distances
    double *redshifts,*comoving_distance;
    redshifts=my_calloc(sizeof(*redshifts),COSMO_DIST_SIZE);
    comoving_distance=my_calloc(sizeof(*comoving_distance),COSMO_DIST_SIZE);
    int Nzdc = set_cosmo_dist(MAX_REDSHIFT_FOR_COSMO_DIST, COSMO_DIST_SIZE, redshifts, comoving_distance, cosmology);
    const DOUBLE inv_speed_of_light=1.0/SPEED_OF_LIGHT;

    gsl_interp *interpolation;
    gsl_interp_accel *accelerator;
    accelerator =  gsl_interp_accel_alloc();
    interpolation = gsl_interp_alloc (gsl_interp_linear,Nzdc);
    gsl_interp_init(interpolation, redshifts, comoving_distance, Nzdc);

    DOUBLE rcube=0.0 ;
    for(int i=0;i<Ngal;i++) {
        const DOUBLE new_phi   = xgal[i];
        const DOUBLE new_theta = ygal[i];
        const DOUBLE new_cz    = zgal[i];
        const DOUBLE dc = gsl_interp_eval(interpolation, redshifts, comoving_distance, new_cz*inv_speed_of_light, accelerator);
        if(dc>rcube) rcube = dc;

        xgal[i] = dc*COSD(new_theta)*COSD(new_phi) ;
        ygal[i] = dc*COSD(new_theta)*SIND(new_phi) ;
        zgal[i] = dc*SIND(new_theta) ;
    }

    if (need_randoms == 1) {
        for(int i=0;i<Nran;i++) {
            const DOUBLE new_phi   = xran[i];
            const DOUBLE new_theta = yran[i];
            const DOUBLE new_cz    = zran[i];
            const DOUBLE dc = gsl_interp_eval(interpolation, redshifts, comoving_distance, new_cz*inv_speed_of_light, accelerator);

            xran[i] = dc*COSD(new_theta)*COSD(new_phi) ;
            yran[i] = dc*COSD(new_theta)*SIND(new_phi) ;
            zran[i] = dc*SIND(new_theta);
        }
    }
    free(redshifts);free(comoving_distance);
    gsl_interp_free(interpolation);
    gsl_interp_accel_free(accelerator);


    /*---Shift-coordinates--------------------------------*/
    if(options.verbose) {
        fprintf(stderr,"%s> maximum distance = %f. ",__FUNCTION__,rcube) ;
    }

    rcube = rcube + 1. ; //add buffer
    for(int i=0;i<Ngal;i++) {
        xgal[i] += rcube ;
        ygal[i] += rcube ;
        zgal[i] += rcube ;
    }

    if(need_randoms == 1) {
        for(int i=0;i<Nran;i++) {
            xran[i] += rcube ;
            yran[i] += rcube ;
            zran[i] += rcube ;
        }
    }
    rcube = 2.0*rcube ;
    const DOUBLE inv_rcube = 1.0/rcube;

    if(options.verbose) {
        fprintf(stderr," Bounding cube size = %f\n",rcube) ;
    }

    /*---Construct-grid-to-speed-up-neighbor-searching----*/
    //First create the 3-d linklist
    int bin_refine_factor=1;
    cellarray_DOUBLE *lattice=NULL;//pointer to the full 3-d volume for galaxies
    cellarray_DOUBLE *randoms_lattice=NULL;//pointer to the full 3-d volume for randoms
    const DOUBLE xmin=0.0,xmax=rcube;
    const DOUBLE ymin=0.0,ymax=rcube;
    const DOUBLE zmin=0.0,zmax=rcube;
    const DOUBLE smin=0.0;

    {
        //new scope -> no need for the nmesh_x/y/z variables since the data are in a cube
        int nmesh_x,nmesh_y,nmesh_z;
        lattice = gridlink_DOUBLE(Ngal, xgal, ygal, zgal,
                                  xmin, xmax,
                                  ymin, ymax,
                                  zmin, zmax,
                                  rmax, rmax, rmax,
                                  bin_refine_factor, bin_refine_factor, bin_refine_factor,
                                  &nmesh_x, &nmesh_y, &nmesh_z,
                                  &options);
        XRETURN(nmesh_x == nmesh_y && nmesh_x == nmesh_z, EXIT_FAILURE, "The number of grid cells along each dimension should be identical. "
                "(nx, ny, nz) = (%d, %d, %d)\n", nmesh_x, nmesh_y, nmesh_z);
        ngrid = nmesh_x;//could have been nmesh_y/nmesh_z -> all three are equal
    }

    if(need_randoms == 1) {
        int nran_x,nran_y,nran_z;
        randoms_lattice = gridlink_DOUBLE(Nran, xran, yran, zran,
                                          xmin, xmax,
                                          ymin, ymax,
                                          zmin, zmax,
                                          rmax, rmax, rmax,
                                          bin_refine_factor, bin_refine_factor, bin_refine_factor,
                                          &nran_x, &nran_y, &nran_z,
                                          &options);
        XRETURN(nran_x == nran_y && nran_x == nran_z, EXIT_FAILURE, "The number of (randoms) grid cells along each dimension should be identical. "
                "(nx, ny, nz) = (%d, %d, %d)\n",nran_x,nran_y,nran_z);
        XRETURN(nran_x == ngrid, EXIT_FAILURE, "The number of grid cells for randoms = %d should be identical to that in the data = %d\n", nran_x, ngrid);
    }
    const int64_t totncells = ngrid * (int64_t) ngrid * ngrid;

    /*---Prepare-radial-arrays----------------------------*/
    uint64_t *counts = my_calloc(sizeof(*counts),nbin);
    DOUBLE **pN = (DOUBLE **) matrix_calloc(sizeof(DOUBLE), nbin, num_pN);

    /* const DOUBLE rstep = rmax/(DOUBLE)nbin ; */
    /* const DOUBLE inv_rstep = ((DOUBLE) 1.0)/rstep; */

    vpf_mocks_func_ptr_DOUBLE vpf_mocks_function_DOUBLE = vpf_mocks_driver_DOUBLE(&options);
    if(vpf_mocks_function_DOUBLE == NULL) {
        return EXIT_FAILURE;
    }
    
    itry=0 ;
    isucceed=0 ;
    int ncenters_written=0;
    int interrupted=0;
    if(options.verbose) {
        init_my_progressbar(nc, &interrupted);
    }
    
    while(isucceed < nc && itry < Nran && interrupt_status_vpf_mocks_DOUBLE == EXIT_SUCCESS) {
        
        if(options.verbose){
            my_progressbar(isucceed,&interrupted);
        }

        DOUBLE xcen,ycen,zcen;
        int Nnbrs_ran=0;
        if((need_randoms == 1 && isucceed > num_centers_in_file) || num_centers_in_file == 0) {
            xcen = xran[itry] ;
            ycen = yran[itry] ;
            zcen = zran[itry] ;
            Nnbrs_ran = count_neighbors_DOUBLE(xcen,ycen,zcen,smin,inv_rcube,rmax,ngrid,randoms_lattice, threshold_neighbors, bin_refine_factor);
            if(Nnbrs_ran == -1) {
                return EXIT_FAILURE;
            }
        } else {
            double rr=0.0;
            const int MAXBUFSIZE=10000;
            char buffer[MAXBUFSIZE];
            XRETURN( fgets(buffer,MAXBUFSIZE,fpcen) != NULL, EXIT_FAILURE,
                     "ERROR: Could not read-in co-ordinates for the centers of the randoms spheres from file %s\n",centers_file);
            int nitems = sscanf(buffer,"%"REAL_FORMAT" %"REAL_FORMAT" %"REAL_FORMAT" %lf",&xcen,&ycen,&zcen,&rr);
            if(nitems != 4) {
                fprintf(stderr,"ERROR in parsing centers file: nitems = %d xcen = %lf ycen = %lf zcen %lf rr = %lf\n",
                        nitems,xcen,ycen,zcen,rr);
                fprintf(stderr,"buffer = `%s' \n",buffer);
            }
            XRETURN(nitems == 4, EXIT_FAILURE, "Read the centers from the centers file (3 positions and 1 radius)");
            XRETURN(rr >= rmax,EXIT_FAILURE, "Rmax from the center file is >= rmax");
            Nnbrs_ran = threshold_neighbors + 1;
        }

        if(Nnbrs_ran > threshold_neighbors) {  //ignore if sphere overlaps edge

            int ix = (int)(ngrid*(xcen-smin)*inv_rcube);
            int iy = (int)(ngrid*(ycen-smin)*inv_rcube);
            int iz = (int)(ngrid*(zcen-smin)*inv_rcube);
            if(ix > ngrid-1) ix--;
            if(iy > ngrid-1) iy--;
            if(iz > ngrid-1) iz--;
            if( ix  < 0 || ix >= ngrid || iy < 0 || iy >= ngrid || iz < 0 || iz >= ngrid) {
                fprintf(stderr,"Error in %s> Positions are outside grid. (X,Y,Z) = (%lf,%lf,%lf) should have been within the range [0.0, %lf]\n",
                        __FUNCTION__,xcen, ycen, zcen, 1.0/inv_rcube);
                return -1;
            }

            for(int k=0;k<nbin;k++) {  //initialize counts
                counts[k] = 0 ;
            }

            /* Compute VPF using (xcen, ycen, zcen) with lattice */
            const int min_ix = (ix - bin_refine_factor) < 0 ?             0:ix - bin_refine_factor;
            const int max_ix = (ix + bin_refine_factor) > ngrid-1 ? ngrid-1:ix + bin_refine_factor;
            const int min_iy = (iy - bin_refine_factor) < 0 ?             0:iy - bin_refine_factor;
            const int max_iy = (iy + bin_refine_factor) > ngrid-1 ? ngrid-1:iy + bin_refine_factor;
            const int min_iz = (iz - bin_refine_factor) < 0 ?             0:iz - bin_refine_factor;
            const int max_iz = (iz + bin_refine_factor) > ngrid-1 ? ngrid-1:iz + bin_refine_factor;
            for(int iix=min_ix;iix<=max_ix;iix++) {
                for(int iiy=min_iy;iiy<=max_iy;iiy++) {
                    for(int iiz=min_iz;iiz<=max_iz;iiz++){
                        const int64_t index = iix*ngrid*ngrid + iiy*ngrid + iiz;
                        const cellarray_DOUBLE *first = &(lattice[index]);
                        DOUBLE *x2 = first->x;
                        DOUBLE *y2 = first->y;
                        DOUBLE *z2 = first->z;
                        int status = vpf_mocks_function_DOUBLE(first->nelements, x2, y2, z2,
                                                               xcen, ycen, zcen,
                                                               rmax, nbin, 
                                                               counts);
                        if(status != EXIT_SUCCESS) {
                            matrix_free((void **) pN, nbin);
                            return status;
                        }
                    }
                }
            }

            
            
            //Output the center into the file -> either
            if((need_randoms == 1 && isucceed > num_centers_in_file) || num_centers_in_file == 0) {
                fprintf(fpcen,"%lf \t %lf \t %lf \t %lf\n",xcen,ycen,zcen,rmax);
                ncenters_written++;
            }


            /* compute cumulative counts, i.e. n1 changes from the number of galaxies
               in shell ibin to  the number of galaxies in shell ibin or any smaller shell */
            for(int ibin=1;ibin<nbin;ibin++){
                counts[ibin]+=counts[ibin-1];
            }

            for(int ibin=0;ibin<nbin;ibin++) { //compute statistics
                for(int i=0;i<num_pN;i++) {
                    if(counts[ibin] == (uint64_t) i) {
                        pN[ibin][i] += (DOUBLE) 1.0;
                    }
                }
            }
            isucceed++ ;
        }
        itry++ ;
    }
    fclose(fpcen);
    free(counts);
    free_cellarray_DOUBLE(lattice, totncells);
    if(need_randoms == 1) {
        free_cellarray_DOUBLE(randoms_lattice, totncells);
    }
    if(interrupt_status_vpf_mocks_DOUBLE != EXIT_SUCCESS) {
        matrix_free((void **) pN, nbin);
        return EXIT_FAILURE;
    }
    
    if(options.verbose) {
        finish_myprogressbar(&interrupted);
        fprintf(stderr,"%s> Placed %d centers out of %d trials.\n",__FUNCTION__,isucceed,itry);
        fprintf(stderr,"%s> num_centers_in_file = %"PRId64" ncenters_written = %d\n",__FUNCTION__,num_centers_in_file,ncenters_written);
    }

    if(isucceed <= 0) {
        fprintf(stderr,"ERROR: Could not place even a single sphere within the volume. Please reduce the radius of the sphere (currently set to %lf)\n", rmax);
        return EXIT_FAILURE;
    } else if(isucceed < nc) {
        fprintf(stderr,"WARNING: Could only place `%d' out of requested `%d' spheres. Increase the random-sample size might improve the situation\n",isucceed,nc);
    }

    //prepare the results
    results->rmax = rmax;
    results->nbin = nbin;
    results->nc   = nc;
    results->num_pN = num_pN;
    results->pN = (double **) matrix_malloc(sizeof(double), nbin, num_pN);
    if(results->pN == NULL) {
        matrix_free((void **) pN, nbin);
        return EXIT_FAILURE;
    }
    const DOUBLE inv_nc = ((DOUBLE) 1.0)/(DOUBLE) isucceed;//actual number of spheres placed
    for(int i=0;i<num_pN;i++) {
        for(int ibin=0;ibin<nbin;ibin++) {
            results->pN[ibin][i] = pN[ibin][i] * inv_nc;
        }
    }
    matrix_free((void **) pN, nbin);

    return EXIT_SUCCESS;
}
