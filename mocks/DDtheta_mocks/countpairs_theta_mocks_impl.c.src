// # -*- mode: c -*-
/* File: countpairs_theta_mocks_impl.c.src */
/*
  This file is a part of the Corrfunc package
  Copyright (C) 2015-- Manodeep Sinha (manodeep@gmail.com)
  License: MIT LICENSE. See LICENSE file under the top-level
  directory at https://github.com/manodeep/Corrfunc/
*/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <signal.h>
#include <unistd.h>

#include "defs.h"
#include "utils.h"
#include "cpu_features.h"
#include "progressbar.h"

#if defined(_OPENMP)
#include <omp.h>
#endif

#include "gridlink_utils_DOUBLE.h"
#include "gridlink_mocks_impl_DOUBLE.h"

#include "countpairs_theta_mocks_impl_DOUBLE.h"
#include "countpairs_theta_mocks_kernels_DOUBLE.c"



int interrupt_status_wtheta_mocks_DOUBLE=EXIT_SUCCESS;

void interrupt_handler_wtheta_mocks_DOUBLE(int signo)
{
    fprintf(stderr,"Received signal = `%s' (signo = %d). Aborting \n",strsignal(signo), signo);
    interrupt_status_wtheta_mocks_DOUBLE = EXIT_FAILURE;
}



int check_ra_dec_DOUBLE(const int64_t N, DOUBLE *ra, DOUBLE *theta)
{
    if(N==0) {
        return EXIT_SUCCESS;
    }
    if(ra == NULL || theta == NULL) {
        fprintf(stderr,"Input arrays can not be NULL. Have RA = %p DEC = %p\n", ra, theta);
        return EXIT_FAILURE;
    }

    int fix_ra  = 0;
    int fix_dec = 0;
    //Check input dec + ra
    for(int64_t i=0;i<N;i++) {
        if(ra[i] < 0.0) {
            fix_ra = 1;
        }
        XRETURN(theta[i] <= 180.0, EXIT_FAILURE, "Declination should not be more than 180. Did you swap ra and dec?");
        if(theta[i] > 90.0) {
            fix_dec = 1;
        }
    }

    if(fix_ra == 1 || fix_dec == 1) {
        if(fix_ra == 1) {
            fprintf(stderr,ANSI_COLOR_YELLOW "DDtheta> Out of range values found for ra. Expected ra to be in the range [0.0,360.0]. Found ra values in [-180,180] -- fixing that" ANSI_COLOR_RESET "\n");
        }
        if(fix_dec == 1) {
            fprintf(stderr,ANSI_COLOR_YELLOW "DDtheta> Out of range values found for dec. Expected dec to be in the range [-90.0,90.0]. Found dec values in [0,180] -- fixing that" ANSI_COLOR_RESET "\n");
        }

        for(int64_t i=0;i<N;i++) {
            if(fix_ra == 1) {
                ra[i] += 180.0;
            }
            if(fix_dec == 1) {
                theta[i] -= 90.0;
            }
        }
    }
    return EXIT_SUCCESS;
}


countpairs_theta_mocks_func_ptr_DOUBLE countpairs_theta_mocks_driver_DOUBLE(const struct config_options *options)
{
    static countpairs_theta_mocks_func_ptr_DOUBLE function = NULL;
    static isa old_isa = (isa) -1;
    if(old_isa == options->instruction_set) {
        return function;
    }


    /* Array of function pointers */
    countpairs_theta_mocks_func_ptr_DOUBLE allfunctions[] = {
        countpairs_theta_mocks_fallback_DOUBLE,
#ifdef __SSE4_2__
        countpairs_theta_mocks_sse_intrinsics_DOUBLE,
#endif
#ifdef __AVX__
        countpairs_theta_mocks_avx_intrinsics_DOUBLE,
#endif
#ifdef __AVX512F__
        countpairs_theta_mocks_avx512_intrinsics_DOUBLE,
#endif
    };

    const int num_functions = sizeof(allfunctions)/sizeof(void *);
    const int fallback_index = 0;
#if defined(__AVX512F__) || defined(__AVX__) || defined(__SSE4_2__)
    const int highest_isa = get_max_usable_isa();
#endif
    int curr_index = 0;

    /* Is the SSE function supported at runtime and enabled at compile-time?*/
    int sse_index = curr_index;
#ifdef __SSE4_2__
    curr_index++;
    if(highest_isa >= SSE42) sse_index = curr_index;
#endif

    /* Now check if AVX is supported by the CPU */
    int avx_index = curr_index;
#ifdef __AVX__
    curr_index++;
    if(highest_isa >= AVX) avx_index = curr_index;
#endif

    /* Check for AVX512F support */
    int avx512_index = curr_index;
#ifdef __AVX512F__
    curr_index++;
    if(highest_isa >= AVX512F) avx512_index = curr_index;
#endif

    if( curr_index != num_functions-1) {
      fprintf(stderr,"ERROR: Bug in code (current index = %d *should equal* num_functions-1 = %d-1)\n",
              curr_index, num_functions);
      return NULL;
    }

    int function_dispatch = num_functions-1;  //Set default to fastest available
    /* Check that cpu supports feature */
    if(options->instruction_set >= 0) {
        switch(options->instruction_set) {
        case(AVX512F):function_dispatch=avx512_index;break;
        case(AVX2):
        case(AVX):function_dispatch=avx_index;break;
        case(SSE42):function_dispatch=sse_index;break;
        default:function_dispatch=fallback_index;break;
        }
    }
    if(function_dispatch >= num_functions) {
      fprintf(stderr,"In %s> ERROR: Could not resolve the correct function.\n Function index = %d must lie between [0, %d)\n",
              __FUNCTION__, function_dispatch, num_functions);
      return NULL;
    }
    function = allfunctions[function_dispatch];
    old_isa = options->instruction_set;

    if(options->verbose){
        // Must be ordered low to high, since higher ISA may be aliased to lower ones
        if(function_dispatch == fallback_index){
            fprintf(stderr,"Using fallback kernel\n");
        } else if(function_dispatch == sse_index){
            fprintf(stderr,"Using SSE kernel\n");
        } else if(function_dispatch == avx_index){
            fprintf(stderr,"Using AVX kernel\n");
        } else if(function_dispatch == avx512_index){
            fprintf(stderr,"Using AVX512 kernel\n");
        } else {
            fprintf(stderr,"Unknown kernel!\n");
            return NULL;
        }
    }

    return function;
}


#include "sglib.h"
static inline int countpairs_theta_mocks_brute_force_DOUBLE(const int64_t N0, DOUBLE *x0, DOUBLE *y0, DOUBLE *z0,
                                                            const int64_t N1, DOUBLE *x1, DOUBLE *y1, DOUBLE *z1,
                                                            const int numthreads,
                                                            const DOUBLE costhetamax, const DOUBLE costhetamin, const int nthetabin,
                                                            const DOUBLE *theta_upp,
                                                            const DOUBLE *costheta_upp,
                                                            results_countpairs_theta *results,
                                                            struct config_options *options,
                                                            struct extra_options *extra)

{
    if(N0 == 0 || N1 == 0) {
        return EXIT_SUCCESS;
    }


    // If no extra options were passed, create dummy options
    // This allows us to pass arguments like "extra->weights0" below;
    // they'll just be NULLs, which is the correct behavior
    struct extra_options dummy_extra;
    if(extra == NULL){
      weight_method_t dummy_method = NONE;
      dummy_extra = get_extra_options(dummy_method);
      extra = &dummy_extra;
    }

    int need_weightavg = extra->weight_method != NONE;

    /* Always print a message saying "brute-force" is running*/
    fprintf(stderr,"Running brute force algorithm\n");
#if defined(_OPENMP)
    omp_set_num_threads(numthreads);
#else
    (void) numthreads;
#endif


#define MULTIPLE_ARRAY_EXCHANGER(type, a, i, j)  { SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE, x0, i, j); \
        SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE, y0, i, j);               \
        SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE, z0, i, j);               \
        for(int w = 0; w < extra->weights0.num_weights; w++) {          \
            SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE, (DOUBLE *) extra->weights0.weights[w], i, j); \
        }                                                               \
    }

    //Sorting on z -> equivalent to sorting on declination
    //(since z := sin(dec) is a monotonic mapping in -90 <= dec <= 90, the domain for dec)
    SGLIB_ARRAY_QUICK_SORT(DOUBLE, z0, N0, SGLIB_NUMERIC_COMPARATOR , MULTIPLE_ARRAY_EXCHANGER);
#undef MULTIPLE_ARRAY_EXCHANGER

    if(x0 != x1) {
#define MULTIPLE_ARRAY_EXCHANGER(type, a, i, j)  { SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE, x1, i, j); \
            SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE, y1, i, j);           \
            SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE, z1, i, j);           \
            for(int w = 0; w < extra->weights1.num_weights; w++){       \
                SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE, (DOUBLE *) extra->weights1.weights[w], i, j); \
            }                                                           \
        }

        //Sorting on z -> equivalent to sorting on declination
        //(since z := sin(dec) is a monotonic mapping in -90 <= dec <= 90, the domain for dec)
        SGLIB_ARRAY_QUICK_SORT(DOUBLE, z1, N1, SGLIB_NUMERIC_COMPARATOR , MULTIPLE_ARRAY_EXCHANGER);
#undef MULTIPLE_ARRAY_EXCHANGER
    }


    struct timeval t0;
    if(options->c_api_timer) {
        gettimeofday(&t0, NULL);
    }
    const int32_t need_thetaavg = options->need_avg_sep;

#if defined(_OPENMP)
    uint64_t all_npairs[numthreads][nthetabin];
    DOUBLE all_thetaavg[numthreads][nthetabin];
    DOUBLE all_weightavg[numthreads][nthetabin];
    memset(all_npairs, 0, sizeof(DOUBLE)*numthreads*nthetabin);
    if(options->need_avg_sep) {
        memset(all_thetaavg, 0, sizeof(DOUBLE)*numthreads*nthetabin);
    }
    if(need_weightavg) {
        memset(all_weightavg, 0, sizeof(DOUBLE)*numthreads*nthetabin);
    }
#else
    uint64_t npairs[nthetabin];
    for(int i=0;i<nthetabin;i++) npairs[i]=0;
    DOUBLE thetaavg[nthetabin], weightavg[nthetabin];
    if(options->need_avg_sep) {
        for(int i=0;i<nthetabin;i++) thetaavg[i] = ZERO;
    }
    if(need_weightavg) {
        for(int i=0;i<nthetabin;i++) weightavg[i] = ZERO;
    }
#endif

    /* runtime dispatch - get the function pointer */
    countpairs_theta_mocks_func_ptr_DOUBLE countpairs_theta_mocks_function_DOUBLE = countpairs_theta_mocks_driver_DOUBLE(options);
    if(countpairs_theta_mocks_function_DOUBLE == NULL) {
        return EXIT_FAILURE;
    }

    const int block_size = 128;
    int64_t numdone=0;
    int interrupted=0,same_cell=0,abort_status=EXIT_SUCCESS;

    if(options->verbose) {
        init_my_progressbar(N0, &interrupted);
    }
#if defined(_OPENMP)
#pragma omp parallel shared(numdone, abort_status, interrupt_status_wtheta_mocks_DOUBLE)
    {
        int tid = omp_get_thread_num();
        uint64_t npairs[nthetabin];
        DOUBLE thetaavg[nthetabin], weightavg[nthetabin];
        for(int i=0;i<nthetabin;i++) {
            npairs[i] = 0;
            if(options->need_avg_sep) {
                thetaavg[i] = ZERO;
            }
            if(need_weightavg) {
                weightavg[i] = ZERO;
            }
        }

#pragma omp for  schedule(dynamic)
#endif
        for(int64_t i=0;i<N0;i+=block_size) {

#if defined(_OPENMP)
#pragma omp flush (abort_status)
#endif
            if(abort_status == EXIT_SUCCESS && interrupt_status_wtheta_mocks_DOUBLE == EXIT_SUCCESS) {
                //omp cancel was introduced in omp 4.0 - so this is my way of checking if loop needs to be cancelled

                /* If the verbose option is not enabled, avoid outputting anything unnecessary*/
                if(options->verbose) {
#if defined(_OPENMP)
                    if (omp_get_thread_num() == 0)
#endif
                        my_progressbar(numdone,&interrupted);


#if defined(_OPENMP)
#pragma omp atomic
#endif
                    numdone+=block_size;
                }

                const int64_t block_size1 = (N0-i) > block_size ? block_size:(N0-i);
                for(int64_t j=0;j<N1;j+=block_size) {
                    const int64_t block_size2 = (N1-j) > block_size ? block_size:(N1-j);
                    DOUBLE *this_thetaavg = need_thetaavg ? thetaavg:NULL;
                    DOUBLE *this_weightavg = need_weightavg ? weightavg:NULL;

                    // Make thread-local copies of the weights structs so we can
                    // advance the pointers
                    weight_struct_DOUBLE this_weights0 = {.num_weights = extra->weights0.num_weights};
                    weight_struct_DOUBLE this_weights1 = {.num_weights = extra->weights1.num_weights};
                    for(int w = 0; w < this_weights0.num_weights; w++){
                        this_weights0.weights[w] = (DOUBLE *) extra->weights0.weights[w] + i;
                        this_weights1.weights[w] = (DOUBLE *) extra->weights1.weights[w] + j;
                    }

                    int status = countpairs_theta_mocks_function_DOUBLE(block_size1, &x0[i], &y0[i], &z0[i], &this_weights0,
                                                                        block_size2, &x1[j], &y1[j], &z1[j], &this_weights1,
                                                                        same_cell,
                                                                        options->fast_acos,
                                                                        costhetamax, costhetamin, nthetabin,
                                                                        costheta_upp,
                                                                        ZERO, ZERO, ZERO, /* min xyz diff */
                                                                        ZERO, ZERO, ZERO, /* closest xyz positions */
                                                                        this_thetaavg, npairs,
                                                                        this_weightavg, extra->weight_method);
                    abort_status |= status;
                } //N1 loop
            } //abort_status condition
        }//N0 loop

#if defined(_OPENMP)
        for(int j=0;j<nthetabin;j++) {
            all_npairs[tid][j] = npairs[j];
            if(options->need_avg_sep) {
                all_thetaavg[tid][j] = thetaavg[j];
            }
            if(need_weightavg) {
                all_weightavg[tid][j] = weightavg[j];
            }
        }
    }//close the omp parallel region
#endif

    if(abort_status != EXIT_SUCCESS || interrupt_status_wtheta_mocks_DOUBLE != EXIT_SUCCESS) {
        return EXIT_FAILURE;
    }

    if(options->verbose) {
        finish_myprogressbar(&interrupted);
    }

#if defined(_OPENMP)
    uint64_t npairs[nthetabin];
    DOUBLE thetaavg[nthetabin], weightavg[nthetabin];
    for(int i=0;i<nthetabin;i++) {
        npairs[i] = 0;
        if(options->need_avg_sep) {
            thetaavg[i] = ZERO;
        }
        if(need_weightavg) {
            weightavg[i] = ZERO;
        }
    }
    for(int i=0;i<numthreads;i++) {
        for(int j=0;j<nthetabin;j++) {
            npairs[j] += all_npairs[i][j];
            if(options->need_avg_sep) {
                thetaavg[j] += all_thetaavg[i][j];
            }
            if(need_weightavg) {
                weightavg[j] += all_weightavg[i][j];
            }
        }
    }
#endif//USE_OMP


    /* Do not add in the corrections for rmin == 0.0 and AUTOCORR
       The brute-force ALWAYS computes a cross-correlation   */
    for(int i=1;i<nthetabin;i++) {
        if(npairs[i] > 0) {
            if(options->need_avg_sep) {
                thetaavg[i] /= (DOUBLE) npairs[i] ;
            }
            if(need_weightavg) {
                weightavg[i] /= (DOUBLE) npairs[i];
            }
        }
    }

    //prepare results
    //Pack in the results
    results->nbin = nthetabin;
    results->npairs = my_malloc(sizeof(*(results->npairs)), nthetabin);
    results->theta_upp = my_malloc(sizeof(*(results->theta_upp))  , nthetabin);
    results->theta_avg = my_malloc(sizeof(*(results->theta_avg))  , nthetabin);
    results->weightavg = my_malloc(sizeof(*(results->weightavg))  , nthetabin);
    if(results->npairs == NULL || results->theta_upp == NULL || results->theta_avg == NULL || results->weightavg == NULL) {
        fprintf(stderr,"Error: Could not allocate memory for %d nbins to hold the results of the pair-counting\n", nthetabin);
        free_results_countpairs_theta(results);
        return EXIT_FAILURE;
    }

    for(int i=0;i<nthetabin;i++) {
        results->npairs[i] = npairs[i];
        results->theta_upp[i] = theta_upp[i];
        results->theta_avg[i] = ZERO;
        if(options->need_avg_sep) {
            results->theta_avg[i] = thetaavg[i];
        }
        results->weightavg[i] = ZERO;
        if(need_weightavg) {
            results->weightavg[i] = weightavg[i];
        }
    }
    if(options->c_api_timer) {
        struct timeval t1;
        gettimeofday(&t1, NULL);
        options->c_api_time = ADD_DIFF_TIME(t0, t1);
    }

    return EXIT_SUCCESS;
}


int countpairs_theta_mocks_DOUBLE(const int64_t ND1, DOUBLE *ra1, DOUBLE *dec1,
                                  const int64_t ND2, DOUBLE *ra2, DOUBLE *dec2,
                                  const int numthreads,
                                  const int autocorr,
                                  const char *binfile,
                                  results_countpairs_theta *results,
                                  struct config_options *options, struct extra_options *extra)
{
    if(ND1 == 0 || ND2 == 0) {
        fprintf(stderr,"Warning: Received 0 particles in at least one of the arrays. len(array1) = %"PRId64" len(array2) = %"PRId64"\n",
                ND1, ND2);
        //Protect the user. If results has a non-NULL pointer value
        //then make the malloc'ed arrays NULL, free(results->npairs)
        //can be called. Also, a good sign that value is not initialized
        if(results != NULL) {
            results->npairs = NULL;
            results->theta_avg = NULL;
            results->weightavg = NULL;
            results->theta_upp = NULL;
        }
        return EXIT_SUCCESS;
    }

    if(options->float_type != sizeof(DOUBLE)) {
        fprintf(stderr,"ERROR: In %s> Can only handle arrays of size=%zu. Got an array of size = %zu\n",
                __FUNCTION__, sizeof(DOUBLE), options->float_type);
        return EXIT_FAILURE;
    }


    // If no extra options were passed, create dummy options
    // This allows us to pass arguments like "extra->weights0" below;
    // they'll just be NULLs, which is the correct behavior
    struct extra_options dummy_extra;
    if(extra == NULL){
      weight_method_t dummy_method = NONE;
      dummy_extra = get_extra_options(dummy_method);
      extra = &dummy_extra;
    }

    int need_weightavg = extra->weight_method != NONE;

    struct timeval t0;
    if(options->c_api_timer) {
        gettimeofday(&t0, NULL);
    }

    options->sort_on_z = 1;
    options->autocorr=autocorr;

    //check the ra-dec inputs (with braces to restrict scope of int status)
    {
        int status = check_ra_dec_DOUBLE(ND1, ra1, dec1);
        if(status != EXIT_SUCCESS) {
            return status;
        }
    }

    if(autocorr==0) {
        int status = check_ra_dec_DOUBLE(ND2, ra2, dec2);
        if(status != EXIT_SUCCESS) {
            return status;
        }
    }

#if defined(_OPENMP)
    omp_set_num_threads(numthreads);
#else
    (void) numthreads;
#endif

    /* setup interrupt handler -> mostly useful during the python execution.
       Let's Ctrl-C abort the extension  */
    SETUP_INTERRUPT_HANDLERS(interrupt_handler_wtheta_mocks_DOUBLE);

    DOUBLE *theta_upp;
    int nthetabin;
    DOUBLE thetamin,thetamax;
    setup_bins_DOUBLE(binfile,&thetamin,&thetamax,&nthetabin,&theta_upp);
    if( ! (thetamin >= 0.0 && thetamax > 0.0 && thetamin < thetamax && thetamax <= 180.0 && nthetabin >= 1) ) {
        fprintf(stderr,"Error: Could not setup with theta bins correctly. (thetamin = %lf, thetamax = %lf, with nbins = %d). Expected non-zero rmin/rmax with thetamax > "
                "thetamin and nbins >=1 \n",thetamin, thetamax, nthetabin);
        return EXIT_FAILURE;
    }

#if defined(_OPENMP)
    if((options->link_in_ra == 0) &&
       (options->bin_refine_factors[1] < numthreads) &&
       (get_bin_refine_scheme(options) == BINNING_DFL)) {
        options->bin_refine_factors[1]=numthreads;
    }
#endif

    /* Only check the ra and dec bin refine factors (not all 3 bin refs) */
    /* As evidenced by the PR #216, the error-message and resetting is not quite right! */
    if(options->link_in_ra && options->bin_refine_factors[0] < 1) {
        fprintf(stderr,"Warning: Linking in RA is requested, so the RA-bin refine factor *must* be >=1. Instead found bin refine factor =%d...resetting\n",
                options->bin_refine_factors[0]);
        reset_bin_refine_factors(options);
    }

    if(options->link_in_dec && options->bin_refine_factors[1] < 1) {
        fprintf(stderr,"Warning: Linking in DEC is requested, so the DEC-bin refine factor *must* be >=1. Instead found bin refine factor =%d...resetting\n",
                options->bin_refine_factors[1]);
        reset_bin_refine_factors(options);
    }

    if(options->max_cells_per_dim == 0) {
        fprintf(stderr,"Warning: Max. cells per dimension is set to 0 - resetting to `NLATMAX' = %d\n", NLATMAX);
        options->max_cells_per_dim = NLATMAX;
    }


    DOUBLE costheta_upp[nthetabin];
    for(int i=0;i<nthetabin;i++) {
        costheta_upp[i] = COSD(theta_upp[i]);
    }
    const DOUBLE costhetamin=costheta_upp[0];
    const DOUBLE costhetamax=costheta_upp[nthetabin-1];

    DOUBLE *X1 = my_malloc(sizeof(*X1),ND1);
    DOUBLE *Y1 = my_malloc(sizeof(*Y1),ND1);
    DOUBLE *Z1 = my_malloc(sizeof(*Z1),ND1);

    if(X1 == NULL || Y1 == NULL || Z1 == NULL) {
        fprintf(stderr,"Error: Could not allocate memory for %"PRId64" particles in dataset #1. Required memory = %"PRIu64" bytes\n",
                ND1, sizeof(DOUBLE)*ND1);
        return EXIT_FAILURE;
    }

    for(int64_t i=0;i<ND1;i++) {
        X1[i] = COSD(dec1[i])*COSD(ra1[i]) ;
        Y1[i] = COSD(dec1[i])*SIND(ra1[i]) ;
        Z1[i] = SIND(dec1[i]);
    }

    DOUBLE *X2=X1,*Y2=Y1,*Z2=Z1;
    if(autocorr==0) {
        X2=my_malloc(sizeof(*X2),ND2);
        Y2=my_malloc(sizeof(*Y2),ND2);
        Z2=my_malloc(sizeof(*Z2),ND2);
        if(X2 == NULL || Y2 == NULL || Z2 == NULL) {
            fprintf(stderr,"Error: Could not allocate memory for %"PRId64" particles in dataset #2. Required memory = %"PRIu64" bytes\n",
                    ND2, sizeof(DOUBLE)*ND2);
            return EXIT_FAILURE;
        }

        for(int64_t i=0;i<ND2;i++) {
            X2[i] = COSD(dec2[i])*COSD(ra2[i]) ;
            Y2[i] = COSD(dec2[i])*SIND(ra2[i]) ;
            Z2[i] = SIND(dec2[i]);
        }
    }

    if(options->link_in_dec==0 && options->link_in_ra==0) {
        // The positions and weights are going to be rearranged inside brute force!
        // The pos are temporary so we don't care.
        // Create and pass a temporary copy of the weights too; otherwise they will get de-synced from the original pos.
        // TODO: Long term, the "right" way to do this while avoiding a memcpy is to somehow sort the original RA/DEC
        // But if we're using the brute-force counter then we probably don't care about performance anyway...

        weight_struct weights0_backup = extra->weights0;
        weight_struct weights1_backup = extra->weights1;

        for(int64_t w = 0; w < extra->weights0.num_weights; w++){
            extra->weights0.weights[w] = my_calloc(sizeof(DOUBLE), ND1);
            if(extra->weights0.weights[w] == NULL) {
                fprintf(stderr,"Error: Could not allocate memory for %"PRId64" particles in dataset #1. Required memory = %"PRIu64" bytes\n",
                        ND1, sizeof(DOUBLE)*ND1);
                return EXIT_FAILURE;
            }
            memcpy(extra->weights0.weights[w], weights0_backup.weights[w], sizeof(DOUBLE)*ND1);
        }

        if(autocorr){
            // The brute-force pair counter knows nothing about autocorrelations
            // So make the weight pointers for the second set just point to the first set
            extra->weights1 = extra->weights0;
        } else {
            for(int64_t w = 0; w < extra->weights1.num_weights; w++){
                extra->weights1.weights[w] = my_malloc(sizeof(DOUBLE), ND2);
                if(extra->weights0.weights[w] == NULL) {
                    fprintf(stderr,"Error: Could not allocate memory for %"PRId64" particles in dataset #2. Required memory = %"PRIu64" bytes\n",
                            ND2, sizeof(DOUBLE)*ND2);
                    return EXIT_FAILURE;
                }
                memcpy(extra->weights1.weights[w], weights1_backup.weights[w], sizeof(DOUBLE)*ND2);
            }
        }

        //this is equivalent to brute force calculating on the entire dataset
        int status = countpairs_theta_mocks_brute_force_DOUBLE(ND1, X1, Y1, Z1,
                                                               ND2, X2, Y2, Z2,
                                                               numthreads,
                                                               costhetamax, costhetamin, nthetabin,
                                                               theta_upp,
                                                               costheta_upp,
                                                               results,
                                                               options,
                                                               extra);
        free(X1);free(Y1);free(Z1);
        if(autocorr == 0) {
            free(X2);free(Y2);free(Z2);
            for(int64_t w = 0; w < extra->weights1.num_weights; w++){
                free(extra->weights1.weights[w]);
            }
        }
        free(theta_upp);

        // Free the temporary weights copy and restore the original pointers
        for(int64_t w = 0; w < extra->weights0.num_weights; w++){
            free(extra->weights0.weights[w]);
        }
        extra->weights0 = weights0_backup;
        extra->weights1 = weights1_backup;

        return status;
    }


    //Create the lattices
    DOUBLE ra_min = MAX_POSITIVE_FLOAT, dec_min = MAX_POSITIVE_FLOAT;
    DOUBLE ra_max = -MAX_POSITIVE_FLOAT,dec_max = -MAX_POSITIVE_FLOAT;
    get_max_min_ra_dec_DOUBLE(ND1, ra1, dec1, &ra_min, &dec_min, &ra_max, &dec_max);
    if(autocorr==0) {
        get_max_min_ra_dec_DOUBLE(ND2, ra2, dec2, &ra_min, &dec_min, &ra_max, &dec_max);
    }

    /*---Create 3-D lattice--------------------------------------*/
    cellarray_mocks_DOUBLE *lattice1=NULL,*lattice2=NULL;
    int nmesh_dec=0, max_nmesh_ra=0;
    int64_t totncells;
    int64_t num_cell_pairs = 0;
    struct cell_pair_DOUBLE *all_cell_pairs = NULL;
    if(options->link_in_ra) {
        int *nmesh_grid_ra=NULL;
        lattice1 = gridlink_mocks_theta_ra_dec_DOUBLE(ND1, ra1, dec1, X1, Y1, Z1, &(extra->weights0),
                                                      ra_min, ra_max,
                                                      dec_min, dec_max,
                                                      options->max_cells_per_dim,
                                                      options->max_cells_per_dim,
                                                      options->bin_refine_factors[0],
                                                      options->bin_refine_factors[1],
                                                      thetamax,
                                                      &totncells,
                                                      &nmesh_dec,
                                                      &max_nmesh_ra,
                                                      &nmesh_grid_ra,
                                                      options);
        int status = lattice1 == NULL ? EXIT_FAILURE: EXIT_SUCCESS;
        if(lattice1 != NULL) {
            lattice2 = lattice1;
            if(autocorr==0) {
                int64_t totncells2;
                int nmesh_dec2, max_nmesh_ra2;
                int *nmesh_grid_ra2=NULL;
                lattice2 = gridlink_mocks_theta_ra_dec_DOUBLE(ND2, ra2, dec2, X2, Y2, Z2, &(extra->weights1),
                                                              ra_min, ra_max,
                                                              dec_min, dec_max,
                                                              options->max_cells_per_dim, options->max_cells_per_dim,
                                                              options->bin_refine_factors[0],
                                                              options->bin_refine_factors[1],
                                                              thetamax,
                                                              &totncells2,
                                                              &nmesh_dec2,
                                                              &max_nmesh_ra2,
                                                              &nmesh_grid_ra2,
                                                              options);

                if(lattice2 == NULL) {
                    status = EXIT_FAILURE;
                } else {
                    if( ! (totncells == totncells2 && nmesh_dec == nmesh_dec2 && max_nmesh_ra == max_nmesh_ra2) ){
                        fprintf(stderr,"ERROR: The two sets of 3-D lattices do not have identical bins. First has dims (%d, %d) while second has (%d, %d)\n",
                                nmesh_dec, max_nmesh_ra, nmesh_dec2, max_nmesh_ra2);
                        status = EXIT_FAILURE;
                    } else {
                        /* Check that each bin in declination has the exact same number of bins in RA for both lattices */
                        for(int i=0;i<nmesh_dec;i++) {
                            if( nmesh_grid_ra[i] != nmesh_grid_ra2[i]) {
                                fprintf(stderr,"For declination bin = %d, the two lattices do not have identical number of RA bins"
                                        "First has RA bins = %d while the second has RA bins = %d\n", i, nmesh_grid_ra[i],nmesh_grid_ra2[i]);
                                status = EXIT_FAILURE;
                                break;
                            }
                        }
                        if(status == EXIT_SUCCESS) {
                            /* Okay the two lattices have exactly the same underlying structure */
                            free(nmesh_grid_ra2);//don't need this anymore.
                        }
                    }//check for the grid structure
                }//lattice2 == NULL else part
            }//autocorr == 0
        } else { //lattice1 != NULL
            //lattice1 is NULL -> brute force
            free(nmesh_grid_ra);
        }



        /* lattice1 and lattice2 should have been assigned. Might be NULL though */
        if(status == EXIT_SUCCESS) {

            all_cell_pairs = generate_cell_pairs_mocks_theta_ra_dec_DOUBLE(lattice1,
                                                                           lattice2,
                                                                           totncells,
                                                                           &num_cell_pairs,
                                                                           thetamax,
                                                                           options->bin_refine_factors[0],
                                                                           options->bin_refine_factors[1],
                                                                           nmesh_dec, max_nmesh_ra,
                                                                           ra_min, ra_max,
                                                                           nmesh_grid_ra,
                                                                           options->enable_min_sep_opt,
                                                                           autocorr);
            if(all_cell_pairs != NULL) {
                free(nmesh_grid_ra);//don't need this anymore either
            } else {
                status = EXIT_FAILURE;
            }
        }

        if(status != EXIT_SUCCESS) {
            /* Cleanup memory here if switching to brute force */
            if(lattice1 != NULL) {
                free_cellarray_mocks_DOUBLE(lattice1,totncells);
            }
            if(autocorr == 0 && lattice2 != NULL) {
                free_cellarray_mocks_DOUBLE(lattice2,totncells);
            }
            lattice1 = NULL; lattice2 = NULL;
        }
    } else {
        /* Only link in declination */
        lattice1 = gridlink_mocks_theta_dec_DOUBLE(ND1,ra1,dec1,X1,Y1,Z1, &(extra->weights0),
                                                   dec_min, dec_max,
                                                   options->max_cells_per_dim,
                                                   options->bin_refine_factors[1],
                                                   thetamax,
                                                   &totncells,
                                                   options);
        int status = lattice1 == NULL ? EXIT_FAILURE: EXIT_SUCCESS;
        if(lattice1 != NULL) {
            /* Do the same for lattice2 */
            lattice2 = lattice1;
            if(autocorr == 0) {
                int64_t totncells_2=0;
                lattice2 = gridlink_mocks_theta_dec_DOUBLE(ND2, ra2, dec2, X2, Y2, Z2, &(extra->weights1),
                                                           dec_min, dec_max,
                                                           options->max_cells_per_dim,
                                                           options->bin_refine_factors[1],
                                                           thetamax,
                                                           &totncells_2,
                                                           options);
                if(lattice2 != NULL) {
                    if( totncells != totncells_2) {
                        fprintf(stderr,"ERROR: In %s> The two sets of 3-D lattices do not have identical bins. "
                                "First has dims (%"PRId64") while second has (%"PRId64")\n",
                                __FUNCTION__,totncells, totncells_2);
                        status = EXIT_FAILURE;
                    }
                } else {
                    //lattice2 is NULL
                    status = EXIT_FAILURE;
                }
            }//autocorr == 0
        }//lattice1 != NULL

        if(status == EXIT_SUCCESS) {
            //The lattice structures are identical -> try to assign ngb cells
            all_cell_pairs = generate_cell_pairs_mocks_theta_dec_DOUBLE(lattice1,
                                                                        lattice2,
                                                                        totncells,
                                                                        &num_cell_pairs,
                                                                        thetamax,
                                                                        options->bin_refine_factors[1],
                                                                        options->enable_min_sep_opt,
                                                                        autocorr);
            if(all_cell_pairs == NULL) {
                status = EXIT_FAILURE;
            }
        }

        if(status != EXIT_SUCCESS) {
            /* Cleanup memory here if aborting */
            if(lattice1 != NULL) {
                free_cellarray_mocks_DOUBLE(lattice1,totncells);
            }
            if(autocorr == 0 && lattice2 != NULL) {
                free_cellarray_mocks_DOUBLE(lattice2,totncells);
            }
            lattice1 = NULL; lattice2 = NULL;
        }//cleaning up on failure
    }//end of linking only in dec


    /* Check if the lattices could not be constructed.
       Probably out of memory -> Run a brute force */
    if(lattice1 == NULL || lattice2 == NULL) {
        fprintf(stderr,"In %s> Could not construct the 3-D lattice structure. Defaulting to brute-force\n",__FUNCTION__);

        // Pass temporary weights
        // TODO: this code is duplicated from above.
        // But putting it inside the kernel would enforce the de-syncing behavior, which we would hope to remove long-term

        weight_struct weights0_backup = extra->weights0;
        weight_struct weights1_backup = extra->weights1;

        for(int64_t w = 0; w < extra->weights0.num_weights; w++){
            extra->weights0.weights[w] = my_malloc(sizeof(DOUBLE), ND1);
            memcpy(extra->weights0.weights[w], weights0_backup.weights[w], sizeof(DOUBLE)*ND1);
        }

        if(autocorr){
            // The brute-force pair counter knows nothing about autocorrelations
            // So make the weight pointers for the second set just point to the first set
            extra->weights1 = extra->weights0;
        } else {
            for(int64_t w = 0; w < extra->weights1.num_weights; w++){
                extra->weights1.weights[w] = my_malloc(sizeof(DOUBLE), ND2);
                memcpy(extra->weights1.weights[w], weights1_backup.weights[w], sizeof(DOUBLE)*ND2);
            }
        }

        //this is equivalent to brute force calculating on the entire dataset
        int status = countpairs_theta_mocks_brute_force_DOUBLE(ND1, X1, Y1, Z1,
                                                               ND2, X2, Y2, Z2,
                                                               numthreads,
                                                               costhetamax, costhetamin, nthetabin,
                                                               theta_upp,
                                                               costheta_upp,
                                                               results,
                                                               options,
                                                               extra);
        free(X1);free(Y1);free(Z1);
        if(autocorr == 0) {
            free(X2);free(Y2);free(Z2);
            for(int64_t w = 0; w < extra->weights1.num_weights; w++){
                free(extra->weights1.weights[w]);
            }
        }
        free(theta_upp);

        // Free the temporary weights copy and restore the original pointers
        for(int64_t w = 0; w < extra->weights0.num_weights; w++){
            free(extra->weights0.weights[w]);
        }
        extra->weights0 = weights0_backup;
        extra->weights1 = weights1_backup;

        return status;
    }

    if(autocorr == 1 && lattice2 != lattice1) {
        fprintf(stderr,"In %s> ERROR: Bug in code. Autocorr is set but the two lattices point to different memory locations\n"
                "lattice1 = %p lattice2 = %p. Please file an issue at the repo (github.com/manodeep/Corrfunc)\n",
                __FUNCTION__,lattice1, lattice2);
        return EXIT_FAILURE;
    }

    if(options->copy_particles) {
        //the lattices have already been made and contain the
        //XYZ arrays.
        free(X1);free(Y1);free(Z1);
        if(autocorr == 0) {
            free(X2);free(Y2);free(Z2);
        }
    }


    /* runtime dispatch - get the function pointer */
    countpairs_theta_mocks_func_ptr_DOUBLE countpairs_theta_mocks_function_DOUBLE = countpairs_theta_mocks_driver_DOUBLE(options);
    if(countpairs_theta_mocks_function_DOUBLE == NULL) {
        free(theta_upp);
        free_cellarray_mocks_DOUBLE(lattice1,totncells);
        if(autocorr==0) {
            free_cellarray_mocks_DOUBLE(lattice2,totncells);
        }
        return EXIT_FAILURE;
    }


#if defined(_OPENMP)
    uint64_t **all_npairs = (uint64_t **) matrix_calloc(sizeof(uint64_t), numthreads, nthetabin);
    DOUBLE **all_thetaavg = NULL;
    if(options->need_avg_sep) {
        all_thetaavg = (DOUBLE **) matrix_calloc(sizeof(DOUBLE),numthreads,nthetabin);
    }
    DOUBLE **all_weightavg = NULL;
    if(need_weightavg) {
      all_weightavg = (DOUBLE **) matrix_calloc(sizeof(DOUBLE),numthreads,nthetabin);
    }
#else
    uint64_t npairs[nthetabin];
    DOUBLE thetaavg[nthetabin], weightavg[nthetabin];
    for(int i=0; i <nthetabin;i++) {
        npairs[i] = 0;
        if(options->need_avg_sep) {
            thetaavg[i] = ZERO;
        }
        if(need_weightavg) {
            weightavg[i] = ZERO;
        }
    }
#endif

    int interrupted=0, numdone=0,abort_status=EXIT_SUCCESS;
    if(options->verbose) {
        init_my_progressbar(num_cell_pairs, &interrupted);
    }


#if defined(_OPENMP)
#pragma omp parallel shared(numdone, abort_status, interrupt_status_wtheta_mocks_DOUBLE)
    {
        int tid = omp_get_thread_num();
        uint64_t npairs[nthetabin];
        DOUBLE thetaavg[nthetabin], weightavg[nthetabin];
        for(int i=0;i<nthetabin;i++) {
            npairs[i] = 0;
            if(options->need_avg_sep) {
                thetaavg[i] = ZERO;
            }
            if(need_weightavg) {
                weightavg[i] = ZERO;
            }
        }

#pragma omp for  schedule(dynamic)
#endif
        /*---Loop-over-all-cell-pairs--------------------*/
        for(int64_t icellpair=0;icellpair<num_cell_pairs;icellpair++) {

#if defined(_OPENMP)
#pragma omp flush (abort_status)
#endif
            if(abort_status == EXIT_SUCCESS && interrupt_status_wtheta_mocks_DOUBLE == EXIT_SUCCESS) {
                //omp cancel was introduced in omp 4.0 - so this is my way of checking if loop needs to be cancelled

                /* If the verbose option is not enabled, avoid outputting anything unnecessary*/
                if(options->verbose) {
#if defined(_OPENMP)
                    if (omp_get_thread_num() == 0)
#endif
                        my_progressbar(numdone,&interrupted);


#if defined(_OPENMP)
#pragma omp atomic
#endif
                    numdone++;
                }

                struct cell_pair_DOUBLE *this_cell_pair = &all_cell_pairs[icellpair];
                DOUBLE *this_thetaavg = options->need_avg_sep ? thetaavg:NULL;
                DOUBLE *this_weightavg = need_weightavg ? weightavg:NULL;

                const int64_t icell = this_cell_pair->cellindex1;
                const int64_t icell2 = this_cell_pair->cellindex2;
                const cellarray_mocks_DOUBLE *first = &lattice1[icell];
                const cellarray_mocks_DOUBLE *second = &lattice2[icell2];

                const int status = countpairs_theta_mocks_function_DOUBLE(first->nelements, first->x, first->y, first->z, &(first->weights),
                                                                          second->nelements, second->x, second->y, second->z, &(second->weights),
                                                                          this_cell_pair->same_cell,
                                                                          options->fast_acos,
                                                                          costhetamax, costhetamin, nthetabin,
                                                                          costheta_upp,
                                                                          this_cell_pair->min_dx, this_cell_pair->min_dy, this_cell_pair->min_dz,
                                                                          this_cell_pair->closest_x1, this_cell_pair->closest_y1, this_cell_pair->closest_z1,
                                                                          this_thetaavg, npairs,
                                                                          this_weightavg, extra->weight_method);

                /* This actually causes a race condition under OpenMP - but mostly
                   I care that an error occurred - rather than the exact value of
                   the error status */
                abort_status |= status;

            }//abort-status
        }//icellpair loop over num_cell_pairs

#if defined(_OPENMP)
        for(int j=0;j<nthetabin;j++) {
            all_npairs[tid][j] = npairs[j];
            if(options->need_avg_sep) {
                all_thetaavg[tid][j] = thetaavg[j];
            }
            if(need_weightavg) {
                all_weightavg[tid][j] = weightavg[j];
            }
        }
    }//close the omp parallel region
#endif
    free(all_cell_pairs);

    if(options->copy_particles == 0) {
        free(X1);free(Y1);free(Z1);
        int64_t *original_index = lattice1[0].original_index;
        int status = reorder_particles_mocks_back_into_original_order_DOUBLE(ND1, original_index, &(extra->weights0));
        if(status != EXIT_SUCCESS) {
            return status;
        }
        if(autocorr == 0) {
            free(X2);free(Y2);free(Z2);
            original_index = lattice2[0].original_index;
            status = reorder_particles_mocks_back_into_original_order_DOUBLE(ND2, original_index, &(extra->weights1));
            if(status != EXIT_SUCCESS) {
                return status;
            }
        }
    }

    free_cellarray_mocks_DOUBLE(lattice1,totncells);
    if(autocorr == 0) {
        free_cellarray_mocks_DOUBLE(lattice2,totncells);
    }

    if(abort_status != EXIT_SUCCESS || interrupt_status_wtheta_mocks_DOUBLE != EXIT_SUCCESS) {
        /* Cleanup memory here if aborting */
        free(theta_upp);
#if defined(_OPENMP)
        matrix_free((void **) all_npairs, numthreads);
        if(options->need_avg_sep) {
            matrix_free((void **) all_thetaavg, numthreads);
        }
        if(need_weightavg) {
            matrix_free((void **) all_weightavg, numthreads);
        }
#endif
        return EXIT_FAILURE;
    }

    if(options->verbose) {
        finish_myprogressbar(&interrupted);
    }


#if defined(_OPENMP)
    uint64_t npairs[nthetabin];
    DOUBLE thetaavg[nthetabin], weightavg[nthetabin];
    for(int i=0;i<nthetabin;i++) {
        npairs[i] = 0;
        if(options->need_avg_sep) {
            thetaavg[i] = ZERO;
        }
        if(need_weightavg) {
            weightavg[i] = ZERO;
        }
    }
    for(int i=0;i<numthreads;i++) {
        for(int j=0;j<nthetabin;j++) {
            npairs[j] += all_npairs[i][j];
            if(options->need_avg_sep) {
                thetaavg[j] += all_thetaavg[i][j];
            }
            if(need_weightavg) {
                weightavg[j] += all_weightavg[i][j];
            }
        }
    }
    matrix_free((void **) all_npairs, numthreads);
    if(options->need_avg_sep) {
        matrix_free((void **) all_thetaavg, numthreads);
    }
    if(need_weightavg) {
        matrix_free((void **) all_weightavg, numthreads);
    }
#endif//USE_OMP

    //The code does not double count for autocorrelations
    //which means the npairs and rpavg values need to be doubled;
    if(autocorr == 1) {
        const uint64_t int_fac = 2;
        const DOUBLE dbl_fac = (DOUBLE) 2.0;
        for(int i=0;i<nthetabin;i++) {
            npairs[i] *= int_fac;
            if(options->need_avg_sep) {
                thetaavg[i] *= dbl_fac;
            }
            if(need_weightavg) {
                weightavg[i] *= dbl_fac;
            }
        }

        /* Is the min. requested separation 0.0 ?*/
        /* The comparison is '<=' rather than '==' only to silence
           the compiler  */
        if(theta_upp[0] <= 0.0) {
            /* Then, add all the self-pairs. This ensures that
               a cross-correlation with two identical datasets
               produces the same result as the auto-correlation  */
            npairs[1] += ND1; //npairs[1] contains the first valid bin.

            // Increasing npairs affects rpavg and weightavg.
            // We don't need to add anything to rpavg; all the self-pairs have 0 separation!
            // The self-pairs have non-zero weight, though.  So, fix that here.
            if(need_weightavg){
                // Keep in mind this is an autocorrelation (i.e. only one particle set to consider)
                weight_func_t_DOUBLE weight_func = get_weight_func_by_method_DOUBLE(extra->weight_method);
                pair_struct_DOUBLE pair = {.num_weights = extra->weights0.num_weights,
                                           .dx.d=0., .dy.d=0., .dz.d=0.,  // always 0 separation
                                           .parx.d=0., .pary.d=0., .parz.d=0.};
                for(int64_t j = 0; j < ND1; j++){
                    for(int w = 0; w < pair.num_weights; w++){
                        pair.weights0[w].d = ((DOUBLE *) extra->weights0.weights[w])[j];
                        pair.weights1[w].d = ((DOUBLE *) extra->weights0.weights[w])[j];
                    }
                    weightavg[1] += weight_func(&pair);
                }
            }
        }
    }

    for(int i=1;i<nthetabin;i++) {
        if(npairs[i] > 0) {
            if(options->need_avg_sep) {
                thetaavg[i] /= (DOUBLE) npairs[i] ;
            }
            if(need_weightavg) {
                weightavg[i] /= (DOUBLE) npairs[i];
            }
        }
    }

    //prepare results
    //Pack in the results
    results->nbin = nthetabin;
    results->npairs = my_malloc(sizeof(*(results->npairs)), nthetabin);
    results->theta_upp = my_malloc(sizeof(*(results->theta_upp))  , nthetabin);
    results->theta_avg = my_malloc(sizeof(*(results->theta_avg))  , nthetabin);
    results->weightavg  = my_calloc(sizeof(*(results->weightavg))  , nthetabin);
    if(results->npairs == NULL || results->theta_upp == NULL || results->theta_avg == NULL || results->weightavg == NULL) {
        fprintf(stderr,"Error: Could not allocate memory for %d nbins to hold the results of the pair-counting\n", nthetabin);
        free_results_countpairs_theta(results);
        free(theta_upp);
        return EXIT_FAILURE;
    }

    for(int i=0;i<nthetabin;i++) {
        results->npairs[i] = npairs[i];
        results->theta_upp[i] = theta_upp[i];
        results->theta_avg[i] = ZERO;
        results->weightavg[i] = ZERO;
        if(options->need_avg_sep) {
            results->theta_avg[i] = thetaavg[i];
        }
        if(need_weightavg) {
            results->weightavg[i] = weightavg[i];
        }
    }
    free(theta_upp);

    /* reset interrupt handlers to default */
    RESET_INTERRUPT_HANDLERS();
    reset_bin_refine_factors(options);

    if(options->c_api_timer) {
        struct timeval t1;
        gettimeofday(&t1, NULL);
        options->c_api_time = ADD_DIFF_TIME(t0, t1);
    }

    return EXIT_SUCCESS;
}
