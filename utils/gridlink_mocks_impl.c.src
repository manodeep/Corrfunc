// # -*- mode: c -*-
/* File: gridlink_mocks.c */
/*
  This file is a part of the Corrfunc package
  Copyright (C) 2015-- Manodeep Sinha (manodeep@gmail.com)
  License: MIT LICENSE. See LICENSE file under the top-level
  directory at https://github.com/manodeep/Corrfunc/
*/

#include <stdio.h>
#include <math.h>
#include <stdlib.h>

#include "gridlink_mocks_impl_DOUBLE.h"

#include "defs.h"
#include "sglib.h"
#include "function_precision.h"
#include "utils.h"

#if defined(_OPENMP)
#include <omp.h>
#endif

#ifndef MEMORY_INCREASE_FAC
#define MEMORY_INCREASE_FAC   1.1
#endif

void free_cellarray_mocks_index_particles_DOUBLE(cellarray_mocks_index_particles_DOUBLE *lattice, const int64_t totncells)
{
    
    for(int64_t i=0;i<totncells;i++){

        free(lattice[i].x);
        free(lattice[i].y);
        free(lattice[i].z);
        free(lattice[i].cz);
        for(int w = 0; w < lattice[i].weights.num_weights; w++){
            free(lattice[i].weights.weights[w]);
        }
        free(lattice[i].ngb_cells);

        /* Might be NULL but free(NULL) is fine (only allocated if enable_min_sep_opt is passed)*/
        free(lattice[i].ngb_min_dx);
        free(lattice[i].ngb_min_dy);
        free(lattice[i].ngb_min_dz);
        free(lattice[i].ngb_closest_icell_xpos);
        free(lattice[i].ngb_closest_icell_ypos);
        free(lattice[i].ngb_closest_icell_zpos);
    }
    free(lattice);
}

void free_cellarray_mocks_index_wtheta_DOUBLE(cellarray_mocks_index_wtheta_DOUBLE *lattice, const int64_t totncells)
{
    
    for(int64_t i=0;i<totncells;i++){
        /* Since extra cells might be located (in case of linking in ra + dec),
           x,y,z might be NULL but free(NULL) is fine*/
        free(lattice[i].x);
        free(lattice[i].y);
        free(lattice[i].z);
        for(int w = 0; w < lattice[i].weights.num_weights; w++){
            free(lattice[i].weights.weights[w]);
        }
        /* Might be NULL but free(NULL) is fine*/
        free(lattice[i].ngb_cells);

        /* Might be NULL but free(NULL) is fine (only allocated if enable_min_sep_opt is passed)*/
        free(lattice[i].ngb_min_dx);
        free(lattice[i].ngb_min_dy);
        free(lattice[i].ngb_min_dz);
        free(lattice[i].ngb_closest_icell_xpos);
        free(lattice[i].ngb_closest_icell_ypos);
        free(lattice[i].ngb_closest_icell_zpos);
    }
    free(lattice);
}


int get_binsize_data_DOUBLE(const DOUBLE xmin,const DOUBLE xmax,
                            const DOUBLE rmax,
                            const int refine_factor, const int max_ncells, DOUBLE *xbinsize, int *nlattice,
                            const struct config_options *options)
{
    const DOUBLE xdiff = (options->periodic && options->boxsize > 0) ? options->boxsize:(xmax-xmin);
    int nmesh=(int)(refine_factor*xdiff/rmax) ;
    nmesh = nmesh < 1 ? 1:nmesh;
    if(options->periodic == 1) {
        if (nmesh<(2*refine_factor+1))  {
            fprintf(stderr,"%s> ERROR:  nlattice = %d is so small that with periodic wrapping the same cells will be counted twice ....exiting\n",__FILE__,nmesh) ;
            fprintf(stderr,"%s> Please reduce Rmax = %"REAL_FORMAT" to be a smaller fraction of the particle distribution region = %"REAL_FORMAT"\n",__FILE__,rmax, xdiff);
            return EXIT_FAILURE;
        }
    }

    if (nmesh>max_ncells)  nmesh=max_ncells;
    *xbinsize = xdiff/nmesh;
    *nlattice = nmesh;
    return EXIT_SUCCESS;
}

void get_max_min_data_DOUBLE(const int64_t ND1, const DOUBLE * restrict X1, const DOUBLE * restrict Y1, const DOUBLE * restrict Z1,
                             DOUBLE *min_x, DOUBLE *min_y, DOUBLE *min_z, DOUBLE *max_x, DOUBLE *max_y, DOUBLE *max_z)
{
    DOUBLE xmin = *min_x, ymin = *min_y, zmin=*min_z;
    DOUBLE xmax = *max_x, ymax = *max_y, zmax=*max_z;

    for(int64_t i=0;i<ND1;i++) {
        if(X1[i] < xmin) xmin=X1[i];
        if(Y1[i] < ymin) ymin=Y1[i];
        if(Z1[i] < zmin) zmin=Z1[i];


        if(X1[i] > xmax) xmax=X1[i];
        if(Y1[i] > ymax) ymax=Y1[i];
        if(Z1[i] > zmax) zmax=Z1[i];
    }
    *min_x=xmin;*min_y=ymin;*min_z=zmin;
    *max_x=xmax;*max_y=ymax;*max_z=zmax;
}

void get_max_min_ra_dec_DOUBLE(const int64_t ND1, const DOUBLE *RA, const DOUBLE *DEC,
                               DOUBLE *ra_min, DOUBLE *dec_min, DOUBLE *ra_max, DOUBLE *dec_max)
{
    DOUBLE xmin = *ra_min, ymin = *dec_min;
    DOUBLE xmax = *ra_max, ymax = *dec_max;

    for(int64_t i=0;i<ND1;i++) {
        if(RA[i]  < xmin) xmin=RA[i];
        if(DEC[i] < ymin) ymin=DEC[i];

        if(RA[i] > xmax) xmax=RA[i];
        if(DEC[i] > ymax) ymax=DEC[i];
    }
    *ra_min=xmin;*dec_min=ymin;
    *ra_max=xmax;*dec_max=ymax;
}


cellarray_mocks_index_particles_DOUBLE * gridlink_mocks_index_particles_DOUBLE(const int64_t np,
                                                                               const DOUBLE *x, const DOUBLE *y, const DOUBLE *z, 
                                                                               const DOUBLE *cz, const weight_struct *weights,
                                                                               const DOUBLE xmin, const DOUBLE xmax,
                                                                               const DOUBLE ymin, const DOUBLE ymax,
                                                                               const DOUBLE zmin, const DOUBLE zmax,
                                                                               const DOUBLE max_x_size,
                                                                               const DOUBLE max_y_size,
                                                                               const DOUBLE max_z_size,
                                                                               const int xbin_refine_factor,
                                                                               const int ybin_refine_factor,
                                                                               const int zbin_refine_factor,
                                                                               int *nlattice_x,
                                                                               int *nlattice_y,
                                                                               int *nlattice_z,
                                                                               const struct config_options *options)
{
    int nmesh_x=0,nmesh_y=0,nmesh_z=0;
    struct timeval t0;
    if(options->verbose) {
      gettimeofday(&t0,NULL);
    }

    DOUBLE xbinsize=ZERO, ybinsize=ZERO, zbinsize=ZERO;
    const int xstatus = get_binsize_data_DOUBLE(xmin,xmax,max_x_size,xbin_refine_factor, options->max_cells_per_dim, &xbinsize, &nmesh_x, options);
    const int ystatus = get_binsize_data_DOUBLE(ymin,ymax,max_y_size,ybin_refine_factor, options->max_cells_per_dim, &ybinsize, &nmesh_y, options);
    const int zstatus = get_binsize_data_DOUBLE(zmin,zmax,max_z_size,zbin_refine_factor, options->max_cells_per_dim, &zbinsize, &nmesh_z, options);
    if(xstatus != EXIT_SUCCESS || ystatus != EXIT_SUCCESS || zstatus != EXIT_SUCCESS) {
      fprintf(stderr,"Received xstatus = %d ystatus = %d zstatus = %d. Error\n", xstatus, ystatus, zstatus);
      return NULL;
    }

    const int64_t totncells = (int64_t) nmesh_x * (int64_t) nmesh_y * (int64_t) nmesh_z;

    const DOUBLE xdiff = xmax-xmin;
    const DOUBLE ydiff = ymax-ymin;
    const DOUBLE zdiff = zmax-zmin;

    const DOUBLE cell_volume=xbinsize*ybinsize*zbinsize;
    const DOUBLE box_volume=xdiff*ydiff*zdiff;
    int64_t expected_n=(int64_t)(np*cell_volume/box_volume*MEMORY_INCREASE_FAC);
    expected_n=expected_n < 2 ? 2:expected_n;

    if(options->verbose) {
      fprintf(stderr,"In %s> Running with [nmesh_x, nmesh_y, nmesh_z]  = %d,%d,%d. ",__FUNCTION__,nmesh_x,nmesh_y,nmesh_z);
    }

    cellarray_mocks_index_particles_DOUBLE *lattice  = (cellarray_mocks_index_particles_DOUBLE *) my_malloc(sizeof(*lattice), totncells);
    int64_t *nallocated = (int64_t *) my_malloc(sizeof(*nallocated), totncells);
    if(lattice == NULL || nallocated == NULL) {
        free(lattice);free(nallocated);
        return NULL;
    }

    for (int64_t index=0;index<totncells;index++) {
        const size_t memsize=sizeof(DOUBLE);
        lattice[index].x = my_malloc(memsize,expected_n);//This allocates extra and is wasteful
        lattice[index].y = my_malloc(memsize,expected_n);//This allocates extra and is wasteful
        lattice[index].z = my_malloc(memsize,expected_n);//This allocates extra and is wasteful
        lattice[index].cz = my_malloc(memsize,expected_n);//This allocates extra and is wasteful
        
        // Now do the same for the weights
        lattice[index].weights.num_weights = (weights == NULL) ? 0 : weights->num_weights;
        int w_alloc_status = EXIT_SUCCESS;
        for(int w = 0; w < lattice[index].weights.num_weights; w++){
          lattice[index].weights.weights[w] = (DOUBLE *) my_malloc(memsize, expected_n);
          if(lattice[index].weights.weights[w] == NULL){
            w_alloc_status = EXIT_FAILURE;
          }
        }

        if(lattice[index].x == NULL || lattice[index].y == NULL || lattice[index].z == NULL ||
           lattice[index].cz == NULL || w_alloc_status == EXIT_FAILURE) {
            for(int64_t i=index;i>=0;i--) {
                free(lattice[index].x);free(lattice[index].y);free(lattice[index].z);free(lattice[index].cz);
                for(int w = 0; w < lattice[index].weights.num_weights; w++){
                    free(lattice[index].weights.weights[w]);
                }
                return NULL;
            }
        }
        nallocated[index] = expected_n;
        lattice[index].nelements=0;
        lattice[index].xbounds[0] = MAX_POSITIVE_FLOAT;
        lattice[index].xbounds[1] = -MAX_POSITIVE_FLOAT;
        lattice[index].ybounds[0] = MAX_POSITIVE_FLOAT;
        lattice[index].ybounds[1] = -MAX_POSITIVE_FLOAT;
        lattice[index].zbounds[0] = MAX_POSITIVE_FLOAT;
        lattice[index].zbounds[1] = -MAX_POSITIVE_FLOAT;
        
        lattice[index].ngb_cells = NULL;
        lattice[index].ngb_min_dx = NULL;
        lattice[index].ngb_min_dy = NULL;
        lattice[index].ngb_min_dz = NULL;
        lattice[index].ngb_closest_icell_xpos = NULL;
        lattice[index].ngb_closest_icell_ypos = NULL;
        lattice[index].ngb_closest_icell_zpos = NULL;
    }

    const DOUBLE xinv=1.0/xbinsize;
    const DOUBLE yinv=1.0/ybinsize;
    const DOUBLE zinv=1.0/zbinsize;

    for (int64_t i=0;i<np;i++)  {
        int ix=(int)((x[i]-xmin)*xinv) ;
        int iy=(int)((y[i]-ymin)*yinv) ;
        int iz=(int)((z[i]-zmin)*zinv) ;

        if (ix>nmesh_x-1)  ix--;    /* this shouldn't happen, but . . . */
        if (iy>nmesh_y-1)  iy--;
        if (iz>nmesh_z-1)  iz--;
        XRETURN(x[i] >= xmin && x[i] <= xmax, NULL, 
               "x[%"PRId64"] = %"REAL_FORMAT" must be within [%"REAL_FORMAT",%"REAL_FORMAT"]\n",
               i, x[i], xmin, xmax);
        XRETURN(y[i] >= ymin && y[i] <= ymax, NULL, 
               "y[%"PRId64"] = %"REAL_FORMAT" must be within [%"REAL_FORMAT",%"REAL_FORMAT"]\n",
               i, y[i], ymin, ymax);
        XRETURN(z[i] >= zmin && z[i] <= zmax, NULL, 
               "z[%"PRId64"] = %"REAL_FORMAT" must be within [%"REAL_FORMAT",%"REAL_FORMAT"]\n",
               i, z[i], zmin, zmax);
        
        XRETURN(ix >= 0 && ix < nmesh_x, NULL, "ix=%d must be within [0,%d)\n", ix, nmesh_x);
        XRETURN(iy >= 0 && iy < nmesh_y, NULL, "iy=%d must be within [0,%d)\n", iy, nmesh_y);
        XRETURN(iz >= 0 && iz < nmesh_z, NULL, "iz=%d must be within [0,%d)\n", iz, nmesh_z);

        const int64_t index = ix*nmesh_y*nmesh_z + iy*nmesh_z + iz;

        if(lattice[index].nelements == nallocated[index]) {
            expected_n = nallocated[index]*MEMORY_INCREASE_FAC;

            //In case expected_n is 1 or MEMORY_INCREASE_FAC is 1.
            //This way, we only increase by a very few particles
            // at a time. Smaller memory footprint
            while(expected_n <= nallocated[index])
                expected_n++;

            const size_t memsize=sizeof(DOUBLE);
            DOUBLE *posx=NULL, *posy=NULL, *posz=NULL, *poscz=NULL;
            int w_alloc_status;
            do{
                posx = my_realloc(lattice[index].x ,memsize,expected_n,"lattice.x");
                posy = my_realloc(lattice[index].y ,memsize,expected_n,"lattice.y");
                posz = my_realloc(lattice[index].z ,memsize,expected_n,"lattice.z");
                poscz = my_realloc(lattice[index].cz ,memsize,expected_n,"lattice.cz");
                
                lattice[index].x  = (posx == NULL)  ? lattice[index].x:posx;
                lattice[index].y  = (posy == NULL)  ? lattice[index].y:posy;
                lattice[index].z  = (posz == NULL)  ? lattice[index].z:posz;
                lattice[index].cz = (poscz == NULL) ? lattice[index].cz:poscz;
                
                w_alloc_status = EXIT_SUCCESS;
                for(int w = 0; w < lattice[index].weights.num_weights; w++){
                  DOUBLE *newweights = (DOUBLE *) my_realloc(lattice[index].weights.weights[w], memsize, expected_n, "lattice.weights");
                  if(newweights == NULL){
                    w_alloc_status = EXIT_FAILURE;
                  } else {
                    lattice[index].weights.weights[w] = newweights;
                  }
                }

                if(posx == NULL || posy == NULL || posz == NULL || poscz == NULL || w_alloc_status == EXIT_FAILURE) {
                    expected_n--;
                }                
            } while(expected_n > nallocated[index] && (posx == NULL ||
                                                       posy == NULL ||
                                                       posz == NULL ||
                                                       poscz == NULL || w_alloc_status == EXIT_FAILURE));

            if(expected_n == nallocated[index]) {
                /*realloc failed. free memory and return */
                fprintf(stderr,"In %s> Reallocation failed,  randomly subsampling the input particle set (currently at %"PRId64" particles) might help\n",
                        __FUNCTION__, np);
                fprintf(stderr,"posx = %p posy = %p posz = %p poscz = %p\n", posx, posy, posz, poscz);
                free_cellarray_mocks_index_particles_DOUBLE(lattice, totncells);
                free(nallocated);
                return NULL;
            }
            nallocated[index] = expected_n;
        }
        XRETURN(lattice[index].nelements < nallocated[index], NULL, 
                ANSI_COLOR_RED"BUG: lattice[%"PRId64"].nelements = %"PRId64" must be less than allocated memory = %"PRId64 ANSI_COLOR_RESET"\n",
                index, lattice[index].nelements, nallocated[index]);

        const int64_t ipos = lattice[index].nelements;
        lattice[index].x[ipos] = x[i];
        lattice[index].y[ipos] = y[i];
        lattice[index].z[ipos] = z[i];
        lattice[index].cz[ipos] = cz[i];
        for(int w = 0; w < lattice[index].weights.num_weights; w++){
            lattice[index].weights.weights[w][ipos] = ((DOUBLE *)weights->weights[w])[i];
        }

        lattice[index].xbounds[0] = x[i] < lattice[index].xbounds[0] ? x[i]:lattice[index].xbounds[0];
        lattice[index].ybounds[0] = y[i] < lattice[index].ybounds[0] ? y[i]:lattice[index].ybounds[0];
        lattice[index].zbounds[0] = z[i] < lattice[index].zbounds[0] ? z[i]:lattice[index].zbounds[0];

        lattice[index].xbounds[1] = x[i] > lattice[index].xbounds[1] ? x[i]:lattice[index].xbounds[1];
        lattice[index].ybounds[1] = y[i] > lattice[index].ybounds[1] ? y[i]:lattice[index].ybounds[1];
        lattice[index].zbounds[1] = z[i] > lattice[index].zbounds[1] ? z[i]:lattice[index].zbounds[1];

        lattice[index].nelements++;
    }
    free(nallocated);

    /* Do we need to sort the particles in Z ? */
    if(options->sort_on_z) {
#if defined(_OPENMP)
#pragma omp parallel for schedule(dynamic)
#endif
        for(int64_t icell=0;icell<totncells;icell++) {
#define MULTIPLE_ARRAY_EXCHANGER(type,a,i,j) { SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE,X,i,j); \
                SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE,Y,i,j);           \
                SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE,Z,i,j);           \
                SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE,CZ,i,j);          \
                for(int w = 0; w < first->weights.num_weights; w++){ \
                    SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE, first->weights.weights[w],i,j);\
                }\
            }
            
            const cellarray_mocks_index_particles_DOUBLE *first=&(lattice[icell]);
            if(first->nelements == 0) continue; 
            
            DOUBLE *X = first->x;
            DOUBLE *Y = first->y;
            DOUBLE *Z = first->z;
            DOUBLE *CZ = first->cz;
            
            SGLIB_ARRAY_QUICK_SORT(DOUBLE, Z, first->nelements, SGLIB_NUMERIC_COMPARATOR , MULTIPLE_ARRAY_EXCHANGER);
#undef MULTIPLE_ARRAY_EXCHANGER
        }
    }
    
    //You can free the extra memory reserved by the mallocs by looping over totncells and doing a realloc(lattice[index].x,sizeof(DOUBLE),lattice[index].nelements,"lattice.x")
    *nlattice_x=nmesh_x;
    *nlattice_y=nmesh_y;
    *nlattice_z=nmesh_z;
    if(options->verbose) {
      struct timeval t1;
      gettimeofday(&t1,NULL);
      fprintf(stderr," Time taken = %7.3lf sec\n",ADD_DIFF_TIME(t0,t1));
    }

    return lattice;
}



int assign_ngb_cells_mocks_index_particles_DOUBLE(struct cellarray_mocks_index_particles_DOUBLE *lattice1,
                                                  struct cellarray_mocks_index_particles_DOUBLE *lattice2, const int64_t totncells,
                                                  const int xbin_refine_factor, const int ybin_refine_factor, const int zbin_refine_factor,
                                                  const int nmesh_x, const int nmesh_y, const int nmesh_z,
                                                  const DOUBLE xmin, const DOUBLE ymin, const DOUBLE zmin,
                                                  const DOUBLE xdiff, const DOUBLE ydiff, const DOUBLE zdiff,
                                                  const DOUBLE max_3D_sep, 
                                                  const int enable_min_sep_opt,
                                                  const int autocorr)
{
    const int64_t nx_ngb = 2*xbin_refine_factor + 1;
    const int64_t ny_ngb = 2*ybin_refine_factor + 1;
    const int64_t nz_ngb = 2*zbin_refine_factor + 1;
    const int64_t max_ngb_cells = nx_ngb * ny_ngb * nz_ngb;

    const DOUBLE xbinsize = xdiff/nmesh_x;
    const DOUBLE ybinsize = ydiff/nmesh_y;
    const DOUBLE zbinsize = zdiff/nmesh_z;
  
    for(int64_t icell=0;icell<totncells;icell++) {
        struct cellarray_mocks_index_particles_DOUBLE *first = &(lattice1[icell]);
        if(first->nelements == 0) continue;
        const int iz = icell % nmesh_z;
        const int ix = icell / (nmesh_y * nmesh_z );
        const int iy = (icell - iz - ix*nmesh_z*nmesh_y)/nmesh_z;
        XRETURN(icell == (ix * nmesh_y * nmesh_z + iy * nmesh_z + (int64_t) iz), EXIT_FAILURE,
                ANSI_COLOR_RED"BUG: Index reconstruction is wrong. icell = %"PRId64" reconstructed index = %"PRId64 ANSI_COLOR_RESET"\n",
                icell, (ix * nmesh_y * nmesh_z + iy * nmesh_z + (int64_t) iz));
    
        first->num_ngb = 0;
        first->ngb_cells = my_malloc(sizeof(*(first->ngb_cells)) , max_ngb_cells);
        if(first->ngb_cells == NULL) {      
            fprintf(stderr,"Error: Could not allocate memory for storing neighbouring cell indices. "
                    "Reducing bin refine factors might help\n");
            return EXIT_FAILURE;
        }
    
        if(enable_min_sep_opt) {
            first->ngb_min_dx = my_malloc(sizeof(*(first->ngb_min_dx)), max_ngb_cells);
            first->ngb_min_dy = my_malloc(sizeof(*(first->ngb_min_dy)), max_ngb_cells);
            first->ngb_min_dz = my_malloc(sizeof(*(first->ngb_min_dz)), max_ngb_cells);
            first->ngb_closest_icell_xpos = my_malloc(sizeof(*(first->ngb_closest_icell_xpos)), max_ngb_cells);
            first->ngb_closest_icell_ypos = my_malloc(sizeof(*(first->ngb_closest_icell_ypos)), max_ngb_cells);
            first->ngb_closest_icell_zpos = my_malloc(sizeof(*(first->ngb_closest_icell_zpos)), max_ngb_cells);
            if(first->ngb_min_dx == NULL || first->ngb_min_dy == NULL || first->ngb_min_dz == NULL ||
               first->ngb_closest_icell_xpos == NULL || first->ngb_closest_icell_ypos == NULL || first->ngb_closest_icell_zpos == NULL) {
                fprintf(stderr,"Error: Could not allocate memory for storing additional quantities for optimizations related to min. separation between cell-pairs.\n"
                        "Reducing bin refine factors and/or disabling optimizations for minimum separations between cell-pairs might help\n");
                return EXIT_FAILURE;
            }
        }
    
    
        for(int iix=-xbin_refine_factor;iix<=xbin_refine_factor;iix++){
            const int iiix = ix + iix;
            if(iiix < 0 || iiix >= nmesh_x) continue;
      
            for(int iiy=-ybin_refine_factor;iiy<=ybin_refine_factor;iiy++) {
                const int iiiy = iy + iiy;
                if(iiiy < 0 || iiiy >= nmesh_y) continue;

                for(int64_t iiz=-zbin_refine_factor;iiz<=zbin_refine_factor;iiz++){
                    const int iiiz = iz + iiz;
                    if(iiiz < 0 || iiiz >= nmesh_z) continue;
            
                    const int64_t icell2 = iiiz + (int64_t) nmesh_z*iiiy + nmesh_z*nmesh_y*iiix;
            
                    //For cases where we are not double-counting (i.e., wp and xi), the same-cell
                    //must always be evaluated. In all other cases, (i.e., where double-counting is occurring)
                    //is used, include that in the ngb_cells! The interface is a lot cleaner in the double-counting
                    //kernels in that case!
                    if((autocorr == 1 && icell2 >= icell) || lattice2[icell2].nelements==0) {
                        continue;
                    }

                    const int64_t ngb_index = first->num_ngb;
                    XRETURN(ngb_index < max_ngb_cells, EXIT_FAILURE,
                            "ngb index = %"PRId64" should be less than max_ngb = %"PRId64"\n", ngb_index, max_ngb_cells);
                    if(enable_min_sep_opt) {
                        const int round_iix_towards_zero = iix < 0 ? +1:(iix > 0 ? -1:0);
                        const int round_iiy_towards_zero = iiy < 0 ? +1:(iiy > 0 ? -1:0);
                        const int round_iiz_towards_zero = iiz < 0 ? +1:(iiz > 0 ? -1:0);
                        const int min_xdiff = iix + round_iix_towards_zero;/* min_xdiff can be signed*/
                        const int min_ydiff = iiy + round_iiy_towards_zero;/* min_ydiff can be signed*/
                        const int min_zdiff = iiz + round_iiz_towards_zero;/* min_zdiff can be signed*/
                  
                        first->ngb_min_dx[ngb_index] = min_xdiff * xbinsize;
                        first->ngb_min_dy[ngb_index] = min_ydiff * ybinsize;
                        first->ngb_min_dz[ngb_index] = min_zdiff * zbinsize;
                  
                        /* Check for periodic boundary conditions....etc*/
                        const DOUBLE x_low = xmin + ix*xbinsize, x_hi = x_low + xbinsize;
                        const DOUBLE y_low = ymin + iy*ybinsize, y_hi = y_low + ybinsize;
                        const DOUBLE z_low = zmin + iz*zbinsize, z_hi = z_low + zbinsize;
                  
                        first->ngb_closest_icell_xpos[ngb_index] = iix < 0 ? x_low:(iix > 0 ? x_hi:ZERO);
                        first->ngb_closest_icell_ypos[ngb_index] = iiy < 0 ? y_low:(iiy > 0 ? y_hi:ZERO);
                        first->ngb_closest_icell_zpos[ngb_index] = iiz < 0 ? z_low:(iiz > 0 ? z_hi:ZERO);
                  
                        int update_min_dx=0,update_min_dy=0,update_min_dz=0;
                        const cellarray_mocks_index_particles_DOUBLE *second =  &(lattice2[icell2]);
                        //chose lower bound if secondary cell is to the left (smaller x), else upper
                        const DOUBLE first_x  = iix < 0 ? first->xbounds[0]:first->xbounds[1];//second condition also contains iix==0
                        //chose upper bound if primary cell is to the right (larger x), else lower
                        const DOUBLE second_x = iix < 0 ? second->xbounds[1]:second->xbounds[0];//second condition also contains iix==0
                        const DOUBLE min_dx = iix != 0 ? (first_x - second_x):ZERO;//ensure min_dx == 0 for iix ==0
                  
                        //repeat for min_dy
                        const DOUBLE first_y  = iiy < 0 ? first->ybounds[0]:first->ybounds[1];//second condition also contains iiy==0
                        const DOUBLE second_y = iiy < 0 ? second->ybounds[1]:second->ybounds[0];//second condition also contains iiy==0
                        const DOUBLE min_dy = iiy != 0  ? (first_y - second_y):ZERO;//ensure min_dy == 0 for iiy ==0
                  
                        //repeat for min_dz
                        const DOUBLE first_z  = iiz < 0 ? first->zbounds[0]:first->zbounds[1];//second condition also contains iiz==0
                        const DOUBLE second_z = iiz < 0 ? second->zbounds[1]:second->zbounds[0];//second condition also contains iiz==0
                        const DOUBLE min_dz = iiz != 0 ? (first_z - second_z):ZERO;//ensure min_dz == 0 for iiz ==0
                  
                        if(max_3D_sep > 0) {
                            const DOUBLE sqr_min_sep_cells = min_dx*min_dx + min_dy*min_dy + min_dz*min_dz;
                            if(sqr_min_sep_cells >= max_3D_sep*max_3D_sep) {
                                continue;
                            }
                            update_min_dx = iix != 0;
                            update_min_dy = iiy != 0;
                            update_min_dz = iiz != 0;
                        }/* end of condition for max_3D_sep */
                        /*Update the ngb_mindx/dy/dz if necessary */
                        if(update_min_dx == 1) {
                            const DOUBLE second_x_low = xmin + iiix*xbinsize, second_x_hi =  xmin + (iiix + 1)*xbinsize;
                            /*second_xdiff has the same sign as min_xdiff -> we can directly add to the signed ngb_min_dx */
                            const DOUBLE second_x_diff_from_cell_edge = iix < 0 ? second->xbounds[1]-second_x_hi:second->xbounds[0]-second_x_low;
                            first->ngb_min_dx[ngb_index] += second_x_diff_from_cell_edge;
                        }
                  
                        if(update_min_dy == 1) {
                            const DOUBLE second_y_low = ymin + iiiy*ybinsize, second_y_hi =  ymin + (iiiy + 1)*ybinsize;
                            /*second_ydiff has the same sign as min_ydiff -> we can directly add to the signed ngb_min_dy */
                            const DOUBLE second_y_diff_from_cell_edge = iiy < 0 ? second->ybounds[1]-second_y_hi:second->ybounds[0]-second_y_low;
                            first->ngb_min_dy[ngb_index] += second_y_diff_from_cell_edge;
                        }
                  
                        if(update_min_dz == 1) {
                            const DOUBLE second_z_low = zmin + iiiz*zbinsize, second_z_hi =  zmin + (iiiz + 1)*zbinsize;
                            /*second_ydiff has the same sign as min_zdiff -> we can directly add to the signed ngb_min_dz */
                            const DOUBLE second_z_diff_from_cell_edge = iiz < 0 ? second->zbounds[1]-second_z_hi:second->zbounds[0]-second_z_low;
                            first->ngb_min_dz[ngb_index] += second_z_diff_from_cell_edge;
                        }
                        /* Finished updating the ngb_mindx/dy/dz */
                        
                    }/* end of if condition for enable_min_sep_opt*/ 

                    //If we have reached here, then this cell *MIGHT* have a pair. We
                    //need to add to the neighbour list
                    first->ngb_cells[ngb_index] = &(lattice2[icell2]);
                    first->num_ngb++; //Update the number of neighbour cells. 
                }
            }
        }
    }
  
    return EXIT_SUCCESS;
}    


/* Create the lattice simply based on declination */
cellarray_mocks_index_wtheta_DOUBLE * gridlink_mocks_theta_dec_DOUBLE(const int64_t np,
                                                                      const DOUBLE *ra, const DOUBLE *dec,
                                                                      const DOUBLE *X, const DOUBLE *Y, const DOUBLE *Z, const weight_struct *weights,
                                                                      const DOUBLE dec_min,const DOUBLE dec_max,
                                                                      const DOUBLE max_dec_size,
                                                                      const int dec_refine_factor,
                                                                      const DOUBLE thetamax,
                                                                      int64_t *totncells,
                                                                      const struct config_options *options)
{
    int64_t expected_n;
    size_t totnbytes=0;
    const DOUBLE dec_diff = dec_max-dec_min;
    const DOUBLE inv_dec_diff = 1.0/dec_diff;

    struct timeval t0;
    if(options->verbose) {
        gettimeofday(&t0,NULL);
    }

    /* Input validation */
    XRETURN(thetamax > 0.0, NULL, "Minimum angular separation = %"REAL_FORMAT" must be positive\n", thetamax);
    XRETURN(dec_diff > 0.0, NULL, "All of the points can not be at the same declination. Declination difference = %"REAL_FORMAT" must be non-zero\n", dec_diff);
    XRETURN(np > 0, NULL, "Number of points =%"PRId64" must be >0\n", np);
    XRETURN(ra != NULL, NULL, "RA must be a valid array \n");
    XRETURN(dec != NULL, NULL, "DEC must be a valid array \n");
    XRETURN(X != NULL, NULL, "X must be a valid array \n");
    XRETURN(Y != NULL, NULL, "Y must be a valid array \n");
    XRETURN(Z != NULL, NULL, "Z must be a valid array \n");
    XRETURN(dec_refine_factor >= 1, NULL, "DEC refine factor must be at least 1\n");
    XRETURN(totncells != NULL, NULL, "Pointer to return the total number of cells must be a valid address\n");
    XRETURN(options != NULL, NULL, "Structure containing code options must be a valid address\n");
    
    /* Protect against accidental changes to compile-time (macro) constant */
    XRETURN(MEMORY_INCREASE_FAC >= 1.0, NULL, "Memory increase factor = %lf must be >=1 \n",MEMORY_INCREASE_FAC);
    
    /* Find the max. number of declination cells that can be */
    const DOUBLE this_ngrid_dec = (dec_diff/thetamax < 1) ? 1:dec_diff/thetamax;
    const int this_ngrid_dec_int = ((int) this_ngrid_dec) * dec_refine_factor;
    int ngrid_dec = this_ngrid_dec_int > max_dec_size ? max_dec_size:this_ngrid_dec_int;
    XRETURN(ngrid_dec >= dec_refine_factor, NULL, "Number of grid cells = %d must be at least the declination refinement factor = %d\n",
            ngrid_dec, dec_refine_factor);

    *totncells = ngrid_dec;

    expected_n=(int64_t)( (np/(DOUBLE) (ngrid_dec)) *MEMORY_INCREASE_FAC);
    expected_n = expected_n < 2 ? 2:expected_n;//at least allocate 2 particles

    /*---Allocate-and-initialize-grid-arrays----------*/
    cellarray_mocks_index_wtheta_DOUBLE *lattice = (cellarray_mocks_index_wtheta_DOUBLE *) my_calloc(sizeof(*lattice),ngrid_dec);
    int64_t *nallocated = my_malloc(sizeof(*nallocated), ngrid_dec);
    if(lattice == NULL || nallocated == NULL) {
        free(lattice);free(nallocated);
        return NULL;
    }
    totnbytes += sizeof(*lattice)*ngrid_dec;
    totnbytes += sizeof(*nallocated)*ngrid_dec;
    for(int icell=0;icell<ngrid_dec;icell++) {
        const size_t memsize = sizeof(DOUBLE);
        lattice[icell].x = my_malloc(memsize,expected_n);
        lattice[icell].y = my_malloc(memsize,expected_n);
        lattice[icell].z = my_malloc(memsize,expected_n);
        
        // Now do the same for the weights
        lattice[icell].weights.num_weights = (weights == NULL) ? 0 : weights->num_weights;
        int w_alloc_status = EXIT_SUCCESS;
        for(int w = 0; w < lattice[icell].weights.num_weights; w++){
            lattice[icell].weights.weights[w] = (DOUBLE *) my_malloc(memsize, expected_n);
            if(lattice[icell].weights.weights[w] == NULL){
                w_alloc_status = EXIT_FAILURE;
            }
        }
        
        if(lattice[icell].x == NULL || lattice[icell].y == NULL || lattice[icell].z == NULL || w_alloc_status == EXIT_FAILURE) {
            for(int k=icell;k>=0;k--) {
                free(lattice[k].x);free(lattice[k].y);free(lattice[k].z);
            }
            for(int w = 0; w < lattice[icell].weights.num_weights; w++){
                free(lattice[icell].weights.weights[w]);
            }
            free(lattice);
            return NULL;
        }
        lattice[icell].nelements=0;
        lattice[icell].dec_bounds[0]=MAX_POSITIVE_FLOAT;
        lattice[icell].dec_bounds[1]=-MAX_POSITIVE_FLOAT;
        lattice[icell].ra_bounds[0]=MAX_POSITIVE_FLOAT;
        lattice[icell].ra_bounds[1]=-MAX_POSITIVE_FLOAT;
        lattice[icell].xbounds[0] = MAX_POSITIVE_FLOAT;
        lattice[icell].xbounds[1] = -MAX_POSITIVE_FLOAT;
        lattice[icell].ybounds[0] = MAX_POSITIVE_FLOAT;
        lattice[icell].ybounds[1] = -MAX_POSITIVE_FLOAT;
        lattice[icell].zbounds[0] = MAX_POSITIVE_FLOAT;
        lattice[icell].zbounds[1] = -MAX_POSITIVE_FLOAT;

        lattice[icell].ngb_cells=NULL;
        lattice[icell].ngb_min_dx = NULL;
        lattice[icell].ngb_min_dy = NULL;
        lattice[icell].ngb_min_dz = NULL;
        lattice[icell].ngb_closest_icell_xpos = NULL;
        lattice[icell].ngb_closest_icell_ypos = NULL;
        lattice[icell].ngb_closest_icell_zpos = NULL;
        lattice[icell].num_ngb=0;
        lattice[icell].ngb_allocated=0;

        nallocated[icell] = expected_n;
        totnbytes += 3 * memsize * expected_n;
    }

    /*---Loop-over-particles-and-build-grid-arrays----*/
    for(int64_t i=0;i<np;i++) {
        int idec = (int)(ngrid_dec*(dec[i]-dec_min)*inv_dec_diff);
        if(idec >=ngrid_dec) idec--;
        XRETURN(idec >= 0 && idec < ngrid_dec, NULL,
                "idec (dec bin index) = %d must be within [0, %d)", idec, ngrid_dec);
        if(lattice[idec].nelements == nallocated[idec]) {
            expected_n = nallocated[idec]*MEMORY_INCREASE_FAC;
            while(expected_n <= lattice[idec].nelements) {
                expected_n++;
            }

            const size_t memsize = sizeof(DOUBLE);
            DOUBLE *posx=NULL, *posy=NULL, *posz=NULL;
            int w_alloc_status;
            do {
                posx = my_realloc(lattice[idec].x,memsize,expected_n,"lattice.x");
                posy = my_realloc(lattice[idec].y,memsize,expected_n,"lattice.y");
                posz = my_realloc(lattice[idec].z,memsize,expected_n,"lattice.z");
                
                lattice[idec].x = (posx == NULL) ? lattice[idec].x:posx;
                lattice[idec].y = (posy == NULL) ? lattice[idec].y:posy;
                lattice[idec].z = (posz == NULL) ? lattice[idec].z:posz;
                
                w_alloc_status = EXIT_SUCCESS;
                for(int w = 0; w < lattice[idec].weights.num_weights; w++){
                    DOUBLE *newweights = (DOUBLE *) my_realloc(lattice[idec].weights.weights[w], memsize, expected_n, "lattice.weights");
                    if(newweights == NULL){
                        w_alloc_status = EXIT_FAILURE;
                    } else {
                        lattice[idec].weights.weights[w] = newweights;
                    }
                }
                
                if(posx == NULL || posy == NULL || posz == NULL || w_alloc_status == EXIT_FAILURE) {
                    expected_n--;
                }
            } while(expected_n > nallocated[idec] && (posx == NULL ||
                                                      posy == NULL ||
                                                      posz == NULL || 
                                                      w_alloc_status == EXIT_FAILURE));
            
            if(expected_n == nallocated[idec]) {
                /*realloc failed. free memory and return */
                fprintf(stderr,"In %s> Reallocation failed,  randomly subsampling the input particle set (currently at %"PRId64" particles) might help\n",
                        __FUNCTION__, np);
                fprintf(stderr,"posx = %p posy = %p posz = %p\n", posx, posy, posz);
                free_cellarray_mocks_index_wtheta_DOUBLE(lattice, *totncells);
                free(nallocated);
                return NULL;
            }
            nallocated[idec] = expected_n;
        }

        XRETURN(lattice[idec].nelements < nallocated[idec],NULL,
                ANSI_COLOR_RED"BUG: lattice[%d].nelements = %"PRId64" must be less than allocated memory = %"PRId64 ANSI_COLOR_RESET"\n",
                idec, lattice[idec].nelements, nallocated[idec]);

        const int64_t ipos=lattice[idec].nelements;
        lattice[idec].x[ipos]  = X[i];
        lattice[idec].y[ipos]  = Y[i];
        lattice[idec].z[ipos]  = Z[i];
        for(int w = 0; w < lattice[idec].weights.num_weights; w++){
            lattice[idec].weights.weights[w][ipos] = ((DOUBLE *)weights->weights[w])[i];
        }

        lattice[idec].dec_bounds[0] = dec[i] < lattice[idec].dec_bounds[0] ? dec[i]:lattice[idec].dec_bounds[0];
        lattice[idec].dec_bounds[1] = dec[i] > lattice[idec].dec_bounds[1] ? dec[i]:lattice[idec].dec_bounds[1];
        
        lattice[idec].ra_bounds[0] = ra[i] < lattice[idec].ra_bounds[0] ? ra[i]:lattice[idec].ra_bounds[0];
        lattice[idec].ra_bounds[1] = ra[i] > lattice[idec].ra_bounds[1] ? ra[i]:lattice[idec].ra_bounds[1];
        
        lattice[idec].xbounds[0] = X[i] < lattice[idec].xbounds[0] ? X[i]:lattice[idec].xbounds[0];
        lattice[idec].ybounds[0] = Y[i] < lattice[idec].ybounds[0] ? Y[i]:lattice[idec].ybounds[0];
        lattice[idec].zbounds[0] = Z[i] < lattice[idec].zbounds[0] ? Z[i]:lattice[idec].zbounds[0];

        lattice[idec].xbounds[1] = X[i] > lattice[idec].xbounds[1] ? X[i]:lattice[idec].xbounds[1];
        lattice[idec].ybounds[1] = Y[i] > lattice[idec].ybounds[1] ? Y[i]:lattice[idec].ybounds[1];
        lattice[idec].zbounds[1] = Z[i] > lattice[idec].zbounds[1] ? Z[i]:lattice[idec].zbounds[1];
        
        lattice[idec].nelements++;
    }
    free(nallocated);
    
    if(options->sort_on_z) {
        for(int64_t icell=0;icell<ngrid_dec;icell++) {
            cellarray_mocks_index_wtheta_DOUBLE *first = &lattice[icell];
            if(first->nelements == 0) continue;
#define MULTIPLE_ARRAY_EXCHANGER(type,a,i,j) { SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE,x,i,j); \
                SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE,y,i,j);           \
                SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE,z,i,j);           \
                for(int w = 0; w < first->weights.num_weights; w++){    \
                    SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE, first->weights.weights[w],i,j); \
                }                                                       \
            }
            
            DOUBLE *x = first->x;
            DOUBLE *y = first->y;
            DOUBLE *z = first->z;
                
            SGLIB_ARRAY_QUICK_SORT(DOUBLE, z, first->nelements, SGLIB_NUMERIC_COMPARATOR , MULTIPLE_ARRAY_EXCHANGER);
#undef MULTIPLE_ARRAY_EXCHANGER
            
        }
    }

    if(options->verbose) {
        struct timeval t1;
        gettimeofday(&t1,NULL);
        fprintf(stderr,"%s> expected_n = %"PRId64" ngrid (declination) = %d np=%"PRId64" Memory required = %0.2lf MB. Time taken = %7.3lf sec \n",
                __FUNCTION__,expected_n,ngrid_dec,np,totnbytes/1024.0/1024.,ADD_DIFF_TIME(t0,t1));
    }
    
    return lattice;
}

int assign_ngb_cells_index_wtheta_dec_DOUBLE(cellarray_mocks_index_wtheta_DOUBLE *lattice1,
                                             cellarray_mocks_index_wtheta_DOUBLE *lattice2,
                                             const int64_t totncells,
                                             const DOUBLE thetamax,
                                             const DOUBLE dec_min, const DOUBLE dec_max,
                                             const int dec_refine_factor,
                                             const int enable_min_sep_opt,
                                             const int autocorr)
{
    /* const DOUBLE max_chord_sep = 2.0*SIND(0.5*thetamax); */
    /*    C = 2.0 * SIN(thetamax/2)
       -> C^2 = 4.0 * SIN^2 (thetamax/2.0)
       -> C^2 = 2.0 * (2 * SIN^2(thetamax/2.0))
       -> C^2 = 2.0 * (1 - COS(thetamax))
     */
    const DOUBLE sqr_max_chord_sep = 2.0 * (1.0 - COSD(thetamax));
    
    /* This ngb is a trivial function. Loop over +- idec from every cell. And that's a neighbour cell */
    const int64_t max_ngb_cells = 2*dec_refine_factor + 1;
    const DOUBLE dec_binsize = (dec_max - dec_min)/totncells;
    for(int64_t icell=0;icell<totncells;icell++) {
        struct cellarray_mocks_index_wtheta_DOUBLE *first = &(lattice1[icell]);
        first->num_ngb = 0;
        if(first->nelements == 0) continue;

        if(enable_min_sep_opt) {
            first->ngb_min_dx = my_malloc(sizeof(*(first->ngb_min_dx)), max_ngb_cells);
            first->ngb_min_dy = my_malloc(sizeof(*(first->ngb_min_dy)), max_ngb_cells);
            first->ngb_min_dz = my_malloc(sizeof(*(first->ngb_min_dz)), max_ngb_cells);
            first->ngb_closest_icell_xpos = my_malloc(sizeof(*(first->ngb_closest_icell_xpos)), max_ngb_cells);
            first->ngb_closest_icell_ypos = my_malloc(sizeof(*(first->ngb_closest_icell_ypos)), max_ngb_cells);
            first->ngb_closest_icell_zpos = my_malloc(sizeof(*(first->ngb_closest_icell_zpos)), max_ngb_cells);
            if(first->ngb_min_dx == NULL || first->ngb_min_dy == NULL || first->ngb_min_dz == NULL ||
               first->ngb_closest_icell_xpos == NULL || first->ngb_closest_icell_ypos == NULL || first->ngb_closest_icell_zpos == NULL) {
                fprintf(stderr,"Error: Could not allocate memory for storing additional quantities for optimizations related to min. separation between cell-pairs.\n"
                        "Reducing bin refine factors and/or disabling optimizations for minimum separations between cell-pairs might help\n");
                return EXIT_FAILURE;
            }
        }
    
        first->ngb_cells = my_malloc(sizeof(*(first->ngb_cells)) , max_ngb_cells);
        if(first->ngb_cells == NULL) {
            fprintf(stderr,"Error: Could not allocate memory to hold neighbouring cells. Requested memory = %zu\n",
                    sizeof(*(first->ngb_cells))*max_ngb_cells);
            return EXIT_FAILURE;
        }
        
        for(int idec=-dec_refine_factor;idec<=dec_refine_factor;idec++) {
            const int64_t icell2 = icell + idec;
            
            if(icell2 < 0 || icell2 >= totncells) continue;
            if(lattice2[icell2].nelements==0 || (autocorr == 1 && icell2 >= icell)) continue;

            const int64_t ngb_index = first->num_ngb;
            /* I could easily use realloc first->ngb_cells but this condition triggering means there is a bug 
               in the original max_ngb_cells calculation. Hence the "failure" */
            XRETURN(ngb_index < max_ngb_cells, EXIT_FAILURE,
                    "ngb index = %"PRId64" should be less than max_ngb = %"PRId64"\n", ngb_index, max_ngb_cells);

            if(enable_min_sep_opt) {
                const DOUBLE dec_low = dec_min + icell2*dec_binsize, dec_hi = dec_low + dec_binsize;
                const DOUBLE z_low = COSD(dec_low), z_hi = COSD(dec_hi);
                first->ngb_closest_icell_xpos[ngb_index] = ZERO;
                first->ngb_closest_icell_ypos[ngb_index] = ZERO;
                first->ngb_closest_icell_zpos[ngb_index] = idec < 0 ? z_low:(idec > 0 ? z_hi:ZERO);

                const DOUBLE min_dx = ZERO, min_dy = ZERO;
                const DOUBLE first_z  = idec < 0 ? first->zbounds[0]:first->zbounds[1];
                const DOUBLE second_z = idec < 0 ? second->zbounds[1]:second->zbounds[0];
                const DOUBLE min_dz = idec != 0 ? (first_z - second_z):ZERO;

                const DOUBLE sqr_min_sep_cells = min_dx*min_dx + min_dy*min_dy + min_dz*min_dz;
                if(sqr_min_sep_cells >= sqr_max_chord_sep) {
                    continue;
                }
            }
            
            first->ngb_cells[ngb_index] = &(lattice2[icell2]);
            first->num_ngb++;
        }
    }
    return EXIT_SUCCESS;
}


#if 0
//These three functions were experimental but never seemed to work.
DOUBLE get_max_ra_diff_two_cells_DOUBLE(const DOUBLE first_dec_vals[2], const DOUBLE second_dec_vals[2], const DOUBLE thetamax)
{
#error This function (probably) does not work - do not use.
    DOUBLE max_ra_diff = -1e10;
    const DOUBLE sin_half_thetamax = SIND(0.5 * thetamax);
    const DOUBLE sin_sqr_half_thetamax = sin_half_thetamax * sin_half_thetamax;
    for(int i=0;i<2;i++) {
        for(int j=0;j<2;j++) {
            //sin^2 (1/2 thetamax)    = sin^2 (1/2 (dec1 - dec2)) + cos(dec1) * cos(dec2) * sin^2(1/2 (max-ra-diff))
            //sin^2 (1/2 max-ra-diff) = [sin^2(1/2 thetamax) - sin^2(1/2 (dec1 - dec2))]/(cos(dec1) * cos(dec2))
            //sin^2 (1/2 max-ra-diff) = first_term/second_term
            //max-ra-diff = 2.0 * ASIN(SQRT(first_term/second_term))
            const DOUBLE half_dec_diff = 0.5*(first_dec_vals[i] - second_dec_vals[j]);
            const DOUBLE sin_half_dec_diff = SIND(half_dec_diff);
            const DOUBLE first_term = sin_sqr_half_thetamax - sin_half_dec_diff * sin_half_dec_diff;
            const DOUBLE second_term = COSD(first_dec_vals[i]) * COSD(second_dec_vals[j]);
            const DOUBLE _tmp = first_term/second_term;
            const DOUBLE sqr_sin_ra_diff = (_tmp > 1.0) ? 1.0:(_tmp < ZERO ? ZERO:_tmp);//make sure numerical precision does not cause impossible values
            const DOUBLE ra_diff = 2.0*ASIN(SQRT(sqr_sin_ra_diff));//in radians
            if (ra_diff > max_ra_diff) max_ra_diff = ra_diff;
        }
    }

    return max_ra_diff * INV_PI_OVER_180;
}


//These three functions were experimental but never seemed to work.
int check_if_two_cells_are_within_ra_range_DOUBLE(DOUBLE first_ra_vals[2], DOUBLE second_ra_vals[2], const DOUBLE max_ra_diff)
{
#error This function (probably) does not work - do not use.
    for(int i=0;i<2;i++) {
        for(int j=0;j<2;j++) {
            DOUBLE diff = first_ra_vals[i] - second_ra_vals[j];
            if(diff >= (DOUBLE) 180.0)  diff -= (DOUBLE) 360.0;
            if(diff < (DOUBLE) -180.0) diff += (DOUBLE) 360.0;

            diff = FABS(diff);
            if(diff <= max_ra_diff) return 1;
        }
    }

    return 0;
}

int64_t check_any_points_in_range_DOUBLE(cellarray_mocks_index_wtheta_DOUBLE *first, cellarray_mocks_index_wtheta_DOUBLE *second, const DOUBLE thetamax)
{
#warning This function is unused. 
    DOUBLE *x1 = first->x;
    DOUBLE *y1 = first->y;
    DOUBLE *z1 = first->z;
    int64_t found = 0;
    const DOUBLE costhetamax = COSD(thetamax);
    for(int64_t i=0;i<first->nelements;i++) {
        DOUBLE *x2 = second->x;
        DOUBLE *y2 = second->y;
        DOUBLE *z2 = second->z;
        for(int64_t j=0;j<second->nelements;j++) {
            const DOUBLE costheta = x1[i]*x2[j] + y1[i]*y2[j] + z1[i]*z2[j];
            if(costheta >= costhetamax) {
                found++;
                /* fprintf(stderr,"Found a particle pair with theta = %lf costheta = %lf costhetamax = %lf\n", */
                /*         ACOS(costheta) * INV_PI_OVER_180, costheta, costhetamax); */
            }
        }
    }

    return found;
}
#endif //if 0 -> commented out experimental and non-functional sections


/* Create the lattice based on declination first, and then on right ascension */
cellarray_mocks_index_wtheta_DOUBLE * gridlink_mocks_theta_ra_dec_DOUBLE(const int64_t np,
                                                                         const DOUBLE *ra, const DOUBLE *dec,
                                                                         const DOUBLE *X, const DOUBLE *Y,
                                                                         const DOUBLE *Z, const weight_struct *weights,
                                                                         const DOUBLE ra_min,const DOUBLE ra_max,
                                                                         const DOUBLE dec_min, const DOUBLE dec_max,
                                                                         const int max_ra_size,
                                                                         const int max_dec_size,
                                                                         const int ra_refine_factor,
                                                                         const int dec_refine_factor,
                                                                         const DOUBLE thetamax,
                                                                         int64_t *ncells,
                                                                         int *ngrid_declination,
                                                                         int *max_nmesh_ra,//not really required - serves as additional checking mechanism
                                                                         int **ngrid_phi,//ngrid in ra, updates on caller -> hence the pointer to pointer
                                                                         const struct config_options *options)
{
    int64_t expected_n;
    size_t totnbytes=0;
    const DOUBLE dec_diff = dec_max - dec_min;
    const DOUBLE ra_diff = ra_max - ra_min;

    /* Input validation */
    XRETURN(thetamax > 0.0, NULL, "Minimum angular separation = %"REAL_FORMAT" must be positive\n", thetamax);
    XRETURN(np > 0, NULL, "Number of points =%"PRId64" must be >0\n", np);
    XRETURN(ra != NULL, NULL, "RA must be a valid array \n");
    XRETURN(dec != NULL, NULL, "DEC must be a valid array \n");
    XRETURN(X != NULL, NULL, "X must be a valid array \n");
    XRETURN(Y != NULL, NULL, "Y must be a valid array \n");
    XRETURN(Z != NULL, NULL, "Z must be a valid array \n");
    XRETURN(ra_refine_factor >= 1, NULL, "RA refine factor must be at least 1\n");
    XRETURN(dec_refine_factor >= 1, NULL, "DEC refine factor must be at least 1\n");
    XRETURN(ncells != NULL, NULL, "Pointer to return the total number of cells must be a valid address\n");
    XRETURN(options != NULL, NULL, "Structure containing code options must be a valid address\n");
    XRETURN(ngrid_declination != NULL, NULL, "Address to return the number of DEC cells must be valid (ngrid_declination is NULL)\n");
    
    
    /* Validate the point distribution requested */
    XRETURN(dec_diff > 0.0, NULL, "All of the points can not be at the same declination. Declination difference = %"REAL_FORMAT" must be non-zero\n", dec_diff);
    XRETURN(ra_diff > 0.0, NULL, "All of the points can not be at the same RA. RA difference = %"REAL_FORMAT" must be non-zero\n", ra_diff);

    /* Protect against accidental edits */
    XRETURN(MEMORY_INCREASE_FAC >= 1.0, NULL, "Memory increase factor = %lf must be >=1 \n",MEMORY_INCREASE_FAC);

    const DOUBLE inv_dec_diff = 1.0/dec_diff;
    const DOUBLE inv_ra_diff = 1.0/ra_diff;

    struct timeval t0;
    if(options->verbose) {
        gettimeofday(&t0,NULL);
    }

    const DOUBLE this_ngrid_dec = (dec_diff/thetamax < 1) ? 1:dec_diff/thetamax;
    const int this_ngrid_dec_int = ((int) this_ngrid_dec) * dec_refine_factor;
    int ngrid_dec = this_ngrid_dec_int > max_dec_size ? max_dec_size:this_ngrid_dec_int;
    ngrid_dec = ngrid_dec < 1 ? 1:ngrid_dec;
    *ngrid_declination=ngrid_dec;
    DOUBLE dec_binsize=dec_diff/ngrid_dec;

    *ngrid_phi = my_malloc(sizeof(**ngrid_phi), ngrid_dec);
    if(*ngrid_phi == NULL) {
        return NULL;
    }
    totnbytes += sizeof(**ngrid_phi)*ngrid_dec;

    /* Use a local pointer. Only one level of dereferencing */
    int *ngrid_ra = *ngrid_phi;

    const DOUBLE costhetamax=COSD(thetamax);
    const DOUBLE sin_half_thetamax=SIND(0.5*thetamax);
    

    //Just make sure that the assign_ngb does not keep adding the same cell over and over
    int max_nmesh_phi = 1;//at least one cell (at the poles, there might be only one cell).
    const DOUBLE max_phi_cell = ra_diff;//must have at least one cell -> max ra binsize := ra_diff/1.0;
    for(int idec=0;idec<ngrid_dec;idec++) {
        DOUBLE this_min_dec;
        const DOUBLE dec_lower = dec_min + idec*dec_binsize;
        const DOUBLE dec_upper = dec_lower + dec_binsize;
        const DOUBLE cos_dec_upper = COSD(dec_upper);
        const DOUBLE cos_dec_lower = COSD(dec_lower);
        DOUBLE cos_min_dec;
        if(cos_dec_lower < cos_dec_upper) {
            this_min_dec = dec_lower;
            cos_min_dec = cos_dec_lower;
        } else {
            this_min_dec = dec_upper;
            cos_min_dec = cos_dec_upper;
        }
        

        //Use the Haversine approx. (https://en.wikipedia.org/wiki/Great-circle_distance)
        // \delta\sigma = 2 asin ( sqrt ( sin^2( 1/2 (phi1 - phi2)) + cos(phi1) * cos(phi2) * sin^2( 1/2 max-ra-diff)) )
        // Since phi1 == phi2 = this_min_dec; cos(this_min_dec) := cos_min_dec
        // => \thetamax = 2 asin (  sqrt( cos_min_dec^2 * sin^2( 1/2 max-ra-diff)) )
        // => \thetamax = 2 asin( cos_min_dec * sin(1/2 max-ra-diff)
        // => sin (1/2 \thetamax) = cos_min_dec * sin(1/2 max-ra-diff)
        // => sin(1/2 max-ra-diff) = sin (1/2 \thetamax)/cos_min_dec
        // => max-ra-diff = 2 * asin( sin(1/2 \thetamax)/cos_min_dec )
        
        DOUBLE phi_cell = max_phi_cell;
        if( (90.0 - ABS(this_min_dec) ) > 1.0) { //make sure min_dec is not close to the pole (within 1 degree)-> divide by zero happens the cosine term
            //Haversine formula but numerical precision issues might cause
            //sin_half_thetamax/cos_min_dec > 1.0 or sin_half_thetamax/cos_min_dec < -1.0
            //at which point arcsin() will barf. Therefore, a two-step process to limit
            //the possible values.
            //Sorry about the pythonic naming convention + the names themselves - MS 3rd April, 2017
            const DOUBLE _tmp = sin_half_thetamax/cos_min_dec;// sin(1/2 thetamax) > 0, cos(min_dec) >= 0 ( -90 <= declination <= 90, thetamax > 0)
            const DOUBLE _tmp1 = _tmp < ZERO ? ZERO:(_tmp > 1.0 ? 1.0:_tmp);
            phi_cell = 2.0 * ASIN( _tmp1 ) * INV_PI_OVER_180;

            //I don't think this condition can trigger any more, now that the 
            //previous phi_cell calculation is split up into two steps - MS 3rd April, 2017
            if(phi_cell <= ZERO) {
                phi_cell = max_phi_cell;
            }

            //NAN's might trigger this condition ?
            if( ! (phi_cell > ZERO) ) {
                fprintf(stderr,"Error: Encountered invalid binsize for RA bins = %"REAL_FORMAT" for declination bin = %d\n", phi_cell, idec);
                fprintf(stderr,"min(declination in bin) = %"REAL_FORMAT" (min_dec)\n", this_min_dec);
                fprintf(stderr,"costhetamax = %"REAL_FORMAT" sin(thetamax/2.0) = %"REAL_FORMAT" cos(min_dec) = %"REAL_FORMAT" \n",
                        costhetamax, sin_half_thetamax, cos_min_dec);
            }
        }
        XRETURN(phi_cell > ZERO, NULL, "Please remove LINK_IN_RA from compile options "
                "(or from the code config options)\n");

        phi_cell = phi_cell > max_phi_cell ? max_phi_cell:phi_cell;
        const DOUBLE this_nmesh_ra = (ra_diff/phi_cell < 1) ? 1:ra_diff/phi_cell; //should be >= 1 since phi_cell is <= ra_diff
        const int this_nmesh_ra_int = ((int) this_nmesh_ra) * ra_refine_factor;
        int nmesh_ra = this_nmesh_ra_int > max_ra_size ? max_ra_size:this_nmesh_ra_int;

        //at least one ra bin
        if(nmesh_ra < 1) {
            nmesh_ra = 1;
        }
        
        if(nmesh_ra > max_nmesh_phi) max_nmesh_phi = nmesh_ra;
        ngrid_ra[idec] = nmesh_ra;
    }
    *max_nmesh_ra = max_nmesh_phi;
    expected_n=(int64_t)( (np/(DOUBLE) (ngrid_dec*max_nmesh_phi)) *MEMORY_INCREASE_FAC);
    expected_n = expected_n < 2 ? 2:expected_n;

    int64_t *ra_offset_for_dec = my_malloc(sizeof(*ra_offset_for_dec), ngrid_dec);
    int64_t offset = 0;
    for(int idec=0;idec<ngrid_dec;idec++) {
        ra_offset_for_dec[idec] = offset;
        offset += ngrid_ra[idec];
    }
    
    /*---Allocate-and-initialize-grid-arrays----------*/
    const int64_t totncells = offset;
    *ncells = totncells;
    cellarray_mocks_index_wtheta_DOUBLE *lattice = my_calloc(sizeof(*lattice), totncells);
    int64_t *nallocated = my_malloc(sizeof(*nallocated), totncells);
    if(lattice == NULL || nallocated == NULL) {
        free(lattice);free(nallocated);
        return NULL;
    }
    totnbytes += sizeof(*lattice) * totncells;
    totnbytes += sizeof(*nallocated) * totncells;
    
    for(int64_t icell=0;icell<totncells;icell++) {
        lattice[icell].x = NULL;
        lattice[icell].y = NULL;
        lattice[icell].z = NULL;
        lattice[icell].dec_bounds[0]=MAX_POSITIVE_FLOAT;
        lattice[icell].dec_bounds[1]=-MAX_POSITIVE_FLOAT;
        lattice[icell].ra_bounds[0]=MAX_POSITIVE_FLOAT;
        lattice[icell].ra_bounds[1]=-MAX_POSITIVE_FLOAT;
        lattice[icell].xbounds[0] = MAX_POSITIVE_FLOAT;
        lattice[icell].xbounds[1] = -MAX_POSITIVE_FLOAT;
        lattice[icell].ybounds[0] = MAX_POSITIVE_FLOAT;
        lattice[icell].ybounds[1] = -MAX_POSITIVE_FLOAT;
        lattice[icell].zbounds[0] = MAX_POSITIVE_FLOAT;
        lattice[icell].zbounds[1] = -MAX_POSITIVE_FLOAT;

        lattice[icell].ngb_cells = NULL;
        lattice[icell].nelements=0;
        lattice[icell].num_ngb=0;
    }
    for(int idec=0;idec<ngrid_dec;idec++) {
        const int nmesh_ra = ngrid_ra[idec];
        for(int ira=0;ira<nmesh_ra;ira++) {
            const int64_t ra_base = ra_offset_for_dec[idec];
            const int64_t index = ra_base + ira;
            const size_t memsize=sizeof(DOUBLE);
            
            lattice[index].x = my_malloc(memsize,expected_n);
            lattice[index].y = my_malloc(memsize,expected_n);
            lattice[index].z = my_malloc(memsize,expected_n);

            // Now do the same for the weights
            lattice[index].weights.num_weights = (weights == NULL) ? 0 : weights->num_weights;
            int w_alloc_status = EXIT_SUCCESS;
            for(int w = 0; w < lattice[index].weights.num_weights; w++){
              lattice[index].weights.weights[w] = (DOUBLE *) my_malloc(memsize, expected_n);
              if(lattice[index].weights.weights[w] == NULL){
                w_alloc_status = EXIT_FAILURE;
              }
            }
        
            if(lattice[index].x == NULL || lattice[index].y == NULL || lattice[index].z == NULL || w_alloc_status == EXIT_FAILURE) {
                /* Since all the x/y/z/ngb_cells are initialized to NULL, 
                   I can call the helper routine directly */
                free_cellarray_mocks_index_wtheta_DOUBLE(lattice, totncells);
                free(lattice);
                free(nallocated);
                return NULL;
            }
            lattice[index].nelements=0;
            nallocated[index]=expected_n;
            totnbytes += 3 * memsize * expected_n;
        }
    }

    /*---Loop-over-particles-and-build-grid-arrays----*/
    for(int64_t i=0;i<np;i++) {
        int idec = (int)(ngrid_dec*(dec[i]-dec_min)*inv_dec_diff);
        if(idec >= ngrid_dec) idec--;
        
        XRETURN(idec >=0 && idec < ngrid_dec, NULL,
                "Declination index for particle position = %d must be within [0, %d)\n",
                idec, ngrid_dec);

        int ira  = (int)(ngrid_ra[idec]*(ra[i]-ra_min)*inv_ra_diff);
        if(ira >=ngrid_ra[idec]) ira--;
        XRETURN(ira >=0 && ira < ngrid_ra[idec],NULL,
                "RA index for particle position = %d must be within [0, %d) for declination bin = %d\n",
                idec, ngrid_ra[idec], idec);

        const int64_t ra_base = ra_offset_for_dec[idec];
        const int64_t index = ra_base + ira;
        if(lattice[index].nelements == nallocated[index]) {
            expected_n = nallocated[index]*MEMORY_INCREASE_FAC;
            while(expected_n <= lattice[index].nelements){
                expected_n++;
            }

            const size_t memsize=sizeof(DOUBLE);
            DOUBLE *posx=NULL, *posy=NULL, *posz = NULL;
            int w_alloc_status;
            do {
                posx = my_realloc(lattice[index].x ,memsize,expected_n,"lattice.x");
                posy = my_realloc(lattice[index].y ,memsize,expected_n,"lattice.y");
                posz = my_realloc(lattice[index].z ,memsize,expected_n,"lattice.z");
                
                lattice[index].x = (posx == NULL) ? lattice[index].x:posx;
                lattice[index].y = (posy == NULL) ? lattice[index].y:posy;
                lattice[index].z = (posz == NULL) ? lattice[index].z:posz;
                
                w_alloc_status = EXIT_SUCCESS;
                for(int w = 0; w < lattice[index].weights.num_weights; w++){
                  DOUBLE *newweights = (DOUBLE *) my_realloc(lattice[index].weights.weights[w], memsize, expected_n, "lattice.weights");
                  if(newweights == NULL){
                    w_alloc_status = EXIT_FAILURE;
                  } else {
                    lattice[index].weights.weights[w] = newweights;
                  }
                }
                
                if(posx == NULL || posy == NULL || posz == NULL || w_alloc_status == EXIT_FAILURE) {
                    expected_n--;
                }
            } while(expected_n > nallocated[index] && (posx == NULL ||
                                                       posy == NULL ||
                                                       posz == NULL ||
                                                       w_alloc_status == EXIT_FAILURE));
            
            if(expected_n == nallocated[index]) {
                /*realloc failed. free memory and return */
                fprintf(stderr,"In %s> Reallocation failed,  randomly subsampling the input particle set (currently at %"PRId64" particles) might help\n",
                        __FUNCTION__, np);
                fprintf(stderr,"posx = %p posy = %p posz = %p\n", posx, posy, posz);
                free_cellarray_mocks_index_wtheta_DOUBLE(lattice, totncells);
                free(nallocated);
                return NULL;
            }
            nallocated[index] = expected_n;
            totnbytes += 3 * (expected_n - nallocated[index]) * memsize;
            nallocated[index] = expected_n;
        }
        XRETURN(lattice[index].nelements < nallocated[index],NULL,
                ANSI_COLOR_RED"BUG: lattice[%"PRId64"].nelements = %"PRId64" must be less than allocated memory = %"PRId64 ANSI_COLOR_RESET"\n",
                index, lattice[index].nelements, nallocated[index]);
        
        const int64_t ipos=lattice[index].nelements;
        lattice[index].x[ipos]  = X[i];
        lattice[index].y[ipos]  = Y[i];
        lattice[index].z[ipos]  = Z[i];
        for(int w = 0; w < lattice[index].weights.num_weights; w++){
            lattice[index].weights.weights[w][ipos] = ((DOUBLE *)weights->weights[w])[i];
        }
        lattice[index].dec_bounds[0] = dec[i] < lattice[index].dec_bounds[0] ? dec[i]:lattice[index].dec_bounds[0];
        lattice[index].dec_bounds[1] = dec[i] > lattice[index].dec_bounds[1] ? dec[i]:lattice[index].dec_bounds[1];
        
        lattice[index].ra_bounds[0] = ra[i] < lattice[index].ra_bounds[0] ? ra[i]:lattice[index].ra_bounds[0];
        lattice[index].ra_bounds[1] = ra[i] > lattice[index].ra_bounds[1] ? ra[i]:lattice[index].ra_bounds[1];

        lattice[index].xbounds[0] = X[i] < lattice[index].xbounds[0] ? X[i]:lattice[index].xbounds[0];
        lattice[index].ybounds[0] = Y[i] < lattice[index].ybounds[0] ? Y[i]:lattice[index].ybounds[0];
        lattice[index].zbounds[0] = Z[i] < lattice[index].zbounds[0] ? Z[i]:lattice[index].zbounds[0];

        lattice[index].xbounds[1] = X[i] > lattice[index].xbounds[1] ? X[i]:lattice[index].xbounds[1];
        lattice[index].ybounds[1] = Y[i] > lattice[index].ybounds[1] ? Y[i]:lattice[index].ybounds[1];
        lattice[index].zbounds[1] = Z[i] > lattice[index].zbounds[1] ? Z[i]:lattice[index].zbounds[1];

        lattice[index].nelements++;
    }
    free(nallocated);
    free(ra_offset_for_dec);
        
    if(options->sort_on_z) {
        for(int64_t icell=0;icell<totncells;icell++) {
            cellarray_mocks_index_wtheta_DOUBLE *first = &lattice[icell];
            if(first->nelements == 0) continue;
#define MULTIPLE_ARRAY_EXCHANGER(type,a,i,j) { SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE,x,i,j); \
                SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE,y,i,j);           \
                SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE,z,i,j); \
                for(int w = 0; w < first->weights.num_weights; w++){ \
                    SGLIB_ARRAY_ELEMENTS_EXCHANGER(DOUBLE, first->weights.weights[w],i,j);\
                }\
            }
            
                DOUBLE *x = first->x;
                DOUBLE *y = first->y;
                DOUBLE *z = first->z;

                //Sorting on z -> equivalent to sorting on declination
                //(since z := sin(dec) is a monotonic mapping in -90 <= dec <= 90, the domain for dec)
                SGLIB_ARRAY_QUICK_SORT(DOUBLE, z, first->nelements, SGLIB_NUMERIC_COMPARATOR , MULTIPLE_ARRAY_EXCHANGER);
#undef MULTIPLE_ARRAY_EXCHANGER
            
        }
    }

    if(options->verbose) {
        struct timeval t1;
        gettimeofday(&t1,NULL);
        fprintf(stderr,"%s> Max. points in cell <= %"PRId64" ngrid (declination) = %d max ngrid (ra) = %d. Number of points = %"PRId64 " Memory required = %0.2g MB."
                " Time taken = %7.3lf sec.\n", __FUNCTION__,expected_n,ngrid_dec, max_nmesh_phi, np, totnbytes/1024./1024.,ADD_DIFF_TIME(t0,t1));
    }
    return lattice;
}


int assign_ngb_cells_index_ra_dec_wtheta_DOUBLE(cellarray_mocks_index_wtheta_DOUBLE *lattice1,
                                                cellarray_mocks_index_wtheta_DOUBLE *lattice2,
                                                const int64_t totncells,
                                                const DOUBLE thetamax,
                                                const int ra_refine_factor, const int dec_refine_factor,
                                                const int ngrid_dec, const int max_ngrid_ra,
                                                const DOUBLE dec_min, const DOUBLE dec_max,
                                                const DOUBLE ra_min, const DOUBLE ra_max,
                                                const int *ngrid_ra,
                                                const int enable_min_sep_opt,
                                                const int autocorr)
{
    const int max_dec_ngb = 2*dec_refine_factor + 1;
    const int max_ra_ngb  = 2*ra_refine_factor + 1;
    /* There might be additional cells on either end for cases where RA
       position changes between first and second cells */
    const int max_ngb_cells = max_dec_ngb * max_ra_ngb;

    const DOUBLE dec_diff = dec_max - dec_min;
    const DOUBLE ra_diff = ra_max - ra_min;
    const DOUBLE inv_ra_diff = 1.0/ra_diff;
    XRETURN( totncells <= max_ngrid_ra*ngrid_dec, EXIT_FAILURE,
             "Total number of cells = %"PRId64" can be at most the product of max RA cells = %d and the number of DEC cells = %d\n",
             totncells, max_ngrid_ra, ngrid_dec);

    /* Since lattice1 is a single dimension array containing dec + ra bins, where the number
       of ra bins per dec bin varies, I need to have the offset (array index, **NOT* pointer offset) 
       for the starting ra cell for each dec bin. 
       Note: lattice2 *must* be of the exact same shape and there the same offsets apply to both lattices
    */
    int64_t *ra_offset_for_dec = my_malloc(sizeof(*ra_offset_for_dec), ngrid_dec);
    if(ra_offset_for_dec == NULL) {
        return EXIT_FAILURE;
    }

    int64_t offset = 0;
    for(int idec=0;idec<ngrid_dec;idec++) {
        ra_offset_for_dec[idec] = offset;
        offset += ngrid_ra[idec];
    }
    XRETURN( totncells == offset, EXIT_FAILURE,
             "Total number of cells = %"PRId64" must be exactly equal to the sum of number of RA cells over all declinations = %"PRId64"\n",
             totncells, offset);
     
    
    for(int idec=0;idec<ngrid_dec;idec++) {
        for(int ira=0;ira<ngrid_ra[idec];ira++) {
            const int64_t ra_base = ra_offset_for_dec[idec];
            const int64_t icell = ra_base + ira;
            struct cellarray_mocks_index_wtheta_DOUBLE *first = &(lattice1[icell]);
            if(first->nelements == 0) continue;
            
            first->num_ngb = 0;
            first->ngb_cells = my_malloc(sizeof(*(first->ngb_cells)), max_ngb_cells);
            XRETURN(first->ngb_cells != NULL, EXIT_FAILURE,
                    "Error: Could not allocate for %d neighbour cells for ra+dec linking. Total memory requested was %zu bytes\n",
                    max_ngb_cells, sizeof(*(first->ngb_cells)) * max_ngb_cells);
            first->ngb_allocated = max_ngb_cells;
            
            for(int i=-dec_refine_factor;i<=dec_refine_factor;i++){
                const int this_dec = idec + i;
                if(this_dec < 0 || this_dec >= ngrid_dec) continue;

                /* Figure out what is the min and max RA cell that any particle in "first" cell could be in 
                   if the "first" cell particle had a declination for this_dec (rather than idec) */
                //include one additional cell -> will get pruned if the separation is too large *and* never be duplicated
                //brute force approach would be to simply loop from 0 to ngrid_ra[this_dec] and prune away.
                const int min_ra_this_dec = (int) (ngrid_ra[this_dec] * (first->ra_bounds[0] - ra_min) * inv_ra_diff) - 1;
                const int max_ra_this_dec = (int) (ngrid_ra[this_dec] * (first->ra_bounds[1] - ra_min) * inv_ra_diff) + 1;

                for(int iira=min_ra_this_dec-ra_refine_factor;iira<=max_ra_this_dec+ra_refine_factor;iira++) {
                    int this_ra = iira + ngrid_ra[this_dec];
                    while(this_ra < 0) {
                        this_ra += ngrid_ra[this_dec];
                    }
                    this_ra = this_ra % ngrid_ra[this_dec];
                    
                    XRETURN(this_ra >= 0 && this_ra < ngrid_ra[this_dec], EXIT_FAILURE,
                            "Error: Cell index = %d for neighbour cell must be within [0, %d) "
                            "min/max ra index computed = [%d, %d]\n"
                            "Please reduce ra/dec refine factors\n",
                            this_ra, ngrid_ra[this_dec], min_ra_this_dec, max_ra_this_dec);
                                                               
                    const int64_t this_ra_base = ra_offset_for_dec[this_dec];
                    const int64_t icell2 = this_ra_base + this_ra;
                    XRETURN(icell2 < totncells, EXIT_FAILURE,
                            "index for ngb cell = %"PRId64" should be less total number of cells = %"PRId64"\n",
                            icell2, totncells);

                    struct cellarray_mocks_index_wtheta_DOUBLE *second = &(lattice2[icell2]);
                    //For cases where we are not double-counting (i.e., auto-corrs), the same-cell
                    //must always be evaluated. In all other cases, (i.e., where double-counting is occurring)
                    //is used, include that in the ngb_cells! The interface is a lot cleaner in the double-counting
                    //kernels in that case!
                    //The second condition essentially halves the number of cell-pairs in auto-corr calculations
                    if(second->nelements==0 || (autocorr==1 && icell2 >= icell)) {
                        continue;
                    }

                    int duplicate_flag = 0;
                    for(int jj=0;jj<first->num_ngb;jj++) {
                        if (second == first->ngb_cells[jj]) {
                            duplicate_flag = 1;
                            break;
                        }
                    }

                    if(duplicate_flag == 1) {
                        continue;
                    }

                    //Check if there is enough memory allocated for ngb_cells to assign this new 'second' cell.
                    if(first->num_ngb == first->ngb_allocated) {
                        //Need to reallocate
                        int expected_n = first->ngb_allocated*MEMORY_INCREASE_FAC;
                        while(expected_n <= first->ngb_allocated){
                            expected_n++;
                        }
                        
                        cellarray_mocks_index_wtheta_DOUBLE **ngb = NULL;
                        //realloc into ngb; however, if realloc fails then first->ngb_cells in untouched and NULL is returned
                        //in ngb. In that case, re-try with a lower number of cells [quantified by 'expected_n']
                        //with the hope that a lower realloc will succeed. However, 'expected_n' must be at least  num_ngb + 1,
                        //otherwise assigning 'second' will be a memory access violation. 
                        do{
                            ngb = my_realloc(first->ngb_cells, sizeof(*(first->ngb_cells)), expected_n,"lattice.ngb_cells");
                            first->ngb_cells = (ngb == NULL) ? first->ngb_cells:ngb;
                            if(ngb == NULL) {
                                expected_n--;
                            }
                        } while(expected_n > first->num_ngb && ngb == NULL);

                        if(expected_n <= first->num_ngb) { //the condition could have been '==' but I included '<=' since those are errors as well
                            /*realloc failed. return error */
                            fprintf(stderr,"In %s> Reallocation for neighbour cells failed. Please reduce ``ra/dec_refine_factors`` "
                                    "by either setting ``struct config_options->bin_refine_factors[0:1] = 1`` or passing the bin "
                                    "(ra/dec) refine factors as parameters. Current (ra, dec) refine factors are: (%d, %d)\n",
                                    __FUNCTION__, ra_refine_factor, dec_refine_factor);
                            return EXIT_FAILURE;
                        }
                        //realloc succeeded -> mark that number of currently allocated slots for 'second' cells. 
                        first->ngb_allocated = expected_n;
                    }
                    
                    XRETURN(first->num_ngb < first->ngb_allocated, EXIT_FAILURE,
                            "Not enough memory allocated to assign the neighbour cell at index = %d should be less than number of ngb cells allocated = %d\n",
                            first->num_ngb, first->ngb_allocated);

                    const int ngb_index = first->num_ngb;
                    first->ngb_cells[ngb_index] = second;
                    first->num_ngb++;
                }//loop over possible range of RA values in this dec bin for the original RA bin in first
            }//loop over neighbouring DEC cells
        }//loop over all RA cells contained in this DEC bin
    }//loop over all DEC cells
    free(ra_offset_for_dec);
    
    return EXIT_SUCCESS;
}


